{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Templado Documentation Last Updated: 2024-04-19 Most of today's templating engines mix code for the required rendering logic with HTML markup in one file and require developers to learn their respective language as well as syntax. \u00bbFinally a template engine that does not require learning a new language or syntax.\u00ab Templado follows a different approach on templating: Being in part inspired by Tempan , Templado's main feature - the template rendering - relies solely on plain and standard HTML markup with a subset of RDFa annotations. The limited amount of display logic required is contained within the engine and triggered by the view model or form when being applied to the document. Templado is Open Source, licensed under the BSD 3-Clause License . This documentation covers Templado 5.0 Please follow this link for documentation on Templado 4.x","title":"Templado Documentation"},{"location":"#templado-documentation","text":"Last Updated: 2024-04-19 Most of today's templating engines mix code for the required rendering logic with HTML markup in one file and require developers to learn their respective language as well as syntax.","title":"Templado Documentation"},{"location":"#finally-a-template-engine-that-does-not-require-learning-a-new-language-or-syntax","text":"Templado follows a different approach on templating: Being in part inspired by Tempan , Templado's main feature - the template rendering - relies solely on plain and standard HTML markup with a subset of RDFa annotations. The limited amount of display logic required is contained within the engine and triggered by the view model or form when being applied to the document. Templado is Open Source, licensed under the BSD 3-Clause License .","title":"\u00bbFinally a template engine that does not require learning a new language or syntax.\u00ab"},{"location":"#this-documentation-covers-templado-50please-follow-this-link-for-documentation-on-templado-4x","text":"","title":"This documentation covers Templado 5.0Please follow this link for documentation on Templado 4.x"},{"location":"first-steps/","text":"Getting Started As with any templating engine, the main goal is to pair a template with a data source. Templado uses View Models and HTML templates to accomplish this. So the first thing we need to do is introduce them to each other. 1. Loading the Template For Templado to operate, we need a Template to work with. From Templado's point of view, every Template is a Document . This can either be a complete HTML page - or just a fragment or snippet. A Templado Document can be instantiated either from a string or by supplying an already created instance of PHP's DOMDocument . For our first steps, we'll be using a String: $document = Templado\\Engine\\Document::fromString(' <!DOCTYPE html> <html lang=\"en\"> <head> <title>Hello World, Templado!</title> </head> <body> <h1 property=\"headline\">My First Template</h1> </body> </html> '); Note While HTML can be represented using either the HTML or the XML serialization format, LibXML 2.x - the underlying engine that powers most of PHP's DOM support - does only support the HTML serialization format up to version 4. For that reason, and to avoid other quirks, Templado uses the XML mode when parsing a string. If you do not want this, feel free to create a DOMDocument by other means and pass that to Templado using the alternative factory method Templado\\Engine\\Document::fromDomDocument . 2. Applying a View Model Once a Document instance is available, a View Model can be applied. Templado relies on RDFa attributes embedded into the HTML to determine which methods to call on the current view model. More details on this, supported attributes and their respective meaning for Templado as well as more complex constructs can be found in the View Models section. The above basic HTML example contains a single RDFa attribute property . Templado uses this attribute, or rather the value of it, as the method name to call on the current view model and to determine what to do. The application of a very basic view Model to change text of the <h1> element could look like this: $document->applyViewModel(new class { public function headline(): string { return 'Hello world!'; } }); The property 's value is \"headline\", thus Templado is going to call the method named \"headline\" on the view model. Given the returned type is a string , the element's text content will be changed. 3. Serializing back to HTML Given the above sample model, Templado will replace the original text ('My First Template') with 'Hello world!'. To verify our success, we can have Templado serialize the Document back to HTML for us. We'll do so by using Templado's HTML Serializer. More on the serializer support can be found in the Serializer section. The HTML Serializer used here will ensure we produce sane HTML 5 output, despite the fact we use the XML mode internally: print $document->asString( new Templado\\Engine\\HTMLSerializer() ); The above should produce this output: <!DOCTYPE html> <html lang=\"en\"> <head> <title>Hello World, Templado!</title> </head> <body> <h1 property=\"headline\">Hello world!</h1> </body> </html> Congratulations, you just rendered your first HTML page using Templado!","title":"First Steps"},{"location":"first-steps/#getting-started","text":"As with any templating engine, the main goal is to pair a template with a data source. Templado uses View Models and HTML templates to accomplish this. So the first thing we need to do is introduce them to each other.","title":"Getting Started"},{"location":"first-steps/#1-loading-the-template","text":"For Templado to operate, we need a Template to work with. From Templado's point of view, every Template is a Document . This can either be a complete HTML page - or just a fragment or snippet. A Templado Document can be instantiated either from a string or by supplying an already created instance of PHP's DOMDocument . For our first steps, we'll be using a String: $document = Templado\\Engine\\Document::fromString(' <!DOCTYPE html> <html lang=\"en\"> <head> <title>Hello World, Templado!</title> </head> <body> <h1 property=\"headline\">My First Template</h1> </body> </html> '); Note While HTML can be represented using either the HTML or the XML serialization format, LibXML 2.x - the underlying engine that powers most of PHP's DOM support - does only support the HTML serialization format up to version 4. For that reason, and to avoid other quirks, Templado uses the XML mode when parsing a string. If you do not want this, feel free to create a DOMDocument by other means and pass that to Templado using the alternative factory method Templado\\Engine\\Document::fromDomDocument .","title":"1. Loading the Template"},{"location":"first-steps/#2-applying-a-view-model","text":"Once a Document instance is available, a View Model can be applied. Templado relies on RDFa attributes embedded into the HTML to determine which methods to call on the current view model. More details on this, supported attributes and their respective meaning for Templado as well as more complex constructs can be found in the View Models section. The above basic HTML example contains a single RDFa attribute property . Templado uses this attribute, or rather the value of it, as the method name to call on the current view model and to determine what to do. The application of a very basic view Model to change text of the <h1> element could look like this: $document->applyViewModel(new class { public function headline(): string { return 'Hello world!'; } }); The property 's value is \"headline\", thus Templado is going to call the method named \"headline\" on the view model. Given the returned type is a string , the element's text content will be changed.","title":"2. Applying a View Model"},{"location":"first-steps/#3-serializing-back-to-html","text":"Given the above sample model, Templado will replace the original text ('My First Template') with 'Hello world!'. To verify our success, we can have Templado serialize the Document back to HTML for us. We'll do so by using Templado's HTML Serializer. More on the serializer support can be found in the Serializer section. The HTML Serializer used here will ensure we produce sane HTML 5 output, despite the fact we use the XML mode internally: print $document->asString( new Templado\\Engine\\HTMLSerializer() ); The above should produce this output: <!DOCTYPE html> <html lang=\"en\"> <head> <title>Hello World, Templado!</title> </head> <body> <h1 property=\"headline\">Hello world!</h1> </body> </html> Congratulations, you just rendered your first HTML page using Templado!","title":"3. Serializing back to HTML"},{"location":"install/","text":"Installation Runtime Requirements Templado merely requires an up-to-date PHP Version with XML and DOM support. So this boils down to the following: PHP >= 8.2.0 Extensions dom libxml Note Please note that when you want to contribute to the development of Templado or if you just want to run the tests or some of the tools used during development of Templado like infection or psalm, additional extensions are required. As this is not a runtime requirement, those are not listed here. Install with Composer Templado is designed to be installed as a library using Composer , the defacto standard to install and manage runtime dependencies for PHP. The easiest way to add Templado to your project is from the CLI: $ composer require templado/engine:^5.0 If you prefer to manually create or edit the composer.json file, please add the following fragment to it. \"require\" : { \"templado/engine\": \"^5.0\" } For Templado, and its dependencies, to be actually installed after manually editing, you'd have to explicitly run composer install . Manual Installation If you do not want to or cannot use Composer for some reason, a manual installation is of course also possible. Keep in mind that you are fully responsible to manage a potential upgrade, dependency resoling and autoloading. If you still insist on a manual installation, feel free to clone the source repository, and switch to whatever is the latest 5.x release tag. For instance: git clone git@github.com:templado/engine.git && cd engine && git switch 5.x.y For the CSSSelector to work, you need to additionally install theseer\\css2xpath : git clone git@github.com:theseer/css2xpath.git Note As you opted for not using Composer, no autoloader has been generated yet. Please update your autoloader accordingly, so the newly installed classes and interfaces can be found. Warning While of course technically possible, using a manual installation is not supported. If you run into any issues with Templado, please ensure the problem is reproducible using a composer based installation before reporting it.","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#runtime-requirements","text":"Templado merely requires an up-to-date PHP Version with XML and DOM support. So this boils down to the following: PHP >= 8.2.0 Extensions dom libxml Note Please note that when you want to contribute to the development of Templado or if you just want to run the tests or some of the tools used during development of Templado like infection or psalm, additional extensions are required. As this is not a runtime requirement, those are not listed here.","title":"Runtime Requirements"},{"location":"install/#install-with-composer","text":"Templado is designed to be installed as a library using Composer , the defacto standard to install and manage runtime dependencies for PHP. The easiest way to add Templado to your project is from the CLI: $ composer require templado/engine:^5.0 If you prefer to manually create or edit the composer.json file, please add the following fragment to it. \"require\" : { \"templado/engine\": \"^5.0\" } For Templado, and its dependencies, to be actually installed after manually editing, you'd have to explicitly run composer install .","title":"Install with Composer"},{"location":"install/#manual-installation","text":"If you do not want to or cannot use Composer for some reason, a manual installation is of course also possible. Keep in mind that you are fully responsible to manage a potential upgrade, dependency resoling and autoloading. If you still insist on a manual installation, feel free to clone the source repository, and switch to whatever is the latest 5.x release tag. For instance: git clone git@github.com:templado/engine.git && cd engine && git switch 5.x.y For the CSSSelector to work, you need to additionally install theseer\\css2xpath : git clone git@github.com:theseer/css2xpath.git Note As you opted for not using Composer, no autoloader has been generated yet. Please update your autoloader accordingly, so the newly installed classes and interfaces can be found. Warning While of course technically possible, using a manual installation is not supported. If you run into any issues with Templado, please ensure the problem is reproducible using a composer based installation before reporting it.","title":"Manual Installation"},{"location":"extend/filters/","text":"","title":"Creating Filters"},{"location":"extend/selectors/","text":"","title":"Creating Selectors"},{"location":"extend/serializers/","text":"","title":"Custom Serialization"},{"location":"extend/transformations/","text":"","title":"Creating Transformations"},{"location":"features/form-handling/","text":"","title":"Form Handling"},{"location":"features/merge/","text":"","title":"Merging Documents"},{"location":"features/serializing/","text":"","title":"Controlling the Serializing"},{"location":"features/transformation/","text":"","title":"Applying Transformations"},{"location":"features/view-model/","text":"View Models Introduction Probably the most essential feature of any templating engine is a means to easily transform a data structure into HTML using, well, a template. There seem to be almost endless ways to define the view logic: From rather limited approaches like merely replacing placeholders, to defining a complete domain specific language. While details of course differ, interestingly enough, most engines seem to agree on embedding the view logic into the template, mixing HTML and custom markup or language constructs into a single file. For rendering, the data is mapped from simple DTOs, xml, json, or - most frequently - associative arrays. These approaches have a tendency to become a mess quickly, being hard to test and to reason about. Wouldn't it be much nicer to have standard HTML files, ready to preview at any time and otherwise controlling the rendering process from outside the template? Using RDFa Instead of mixing view logic with markup by embedding instructions into the HTML for a clean separation of concerns, we'd want the logic part to be outside the markup. Yet, for a templating engine to understand how and where to operate, some sort of reference information needs to be provided nevertheless. The best way to do this is by enriching the HTML with structuring metadata, giving the HTML a semantic structure and providing meaning beyond the markup required for a browser to render it: <section property=\"author\"> <h3 property=\"name\">John Doe</h3> <a property=\"email\" typeoOf=\"business\" href=\"mailto:john@example.org\">E-Mail me</a> </section> The above HTML fragment has been annotated with RDFa attributes, a W3C standard to enrich markup with semantic information. In this case, only the property attribute has been used though. When following the tree structure, one can now understand that the text content of the \"h3\" element contains the name of an author and that his business email address is \"john@example.org\". Instead of reinventing the wheel and coming up with a proprietary set of attributes, Templado makes use of these standard attributes to map data from a View Model into the HTML. This is done by calling the relevant method from or by accessing a public property of the given view model. Depending on the returned type, Templado will decide what to do next. How rendering works The view model renderer operates on the internal DOM representation of the template: Starting from the root element - also called DocumentElement -, Templado iterates over all its children and also follows the paths down each respective subtree recursively. Whenever one of the RDFa attributes property , typeof or vocab is encountered, the method associated with it will get called on the current view model. If the returned value for a property triggered call happens to be an object which is not an iterator or generator, it's considered a view model and thus replaces the view model for the current tree position and all their nested elements - until potentially overwritten by yet another view model. This effectively allows for walking down the document tree. This probably is best explained with an example. Let's assume this very basic HTML fragment is our template: <article property=\"article\"> <h1>Article Headline</h1> <section property=\"intro\"> <h2>Headlaine without property attribute</h2> <p property=\"content\">This is the default text</p> </section> </body> The above example contains a html fragment with a nested structure. While there could be any number of elements in between, basically only the property attributes - or rather their respective values - are relevant in this example for the model nesting. Walking down the tree, the nesting is article > intro > content . That means, we initially need a view model we can call article() on. As we're having a nested structure and want to walk down the tree, we need article() to return an object. On the returned object, Templado will call intro() . That's because the next element with a property attribute found while walking down the tree is the section element and the property 's value is \"intro\". Given we want to continue walking the tree, this method should also return an object. We again turn it into a context view model. The next element with a property attribute is the p element. Templado thus calls content() on the current view model, which is the one returned from intro() before. Assuming we want to set the text of the p element, we want that method to return a string. Expressed in PHP code, this could look like this: class MyRootViewModel { public function article(): Article { return new Article(); } } class Article { public function section(): Section { return new Section(); } } class Section { public function p(): string { return 'View Model text for p element here'; } } Given the required methods do not conflict, and we do not have any need for actual view logic other than the nesting, we could - for this very simple example at least - put all this into a single view model class: class MyRootViewModel { public function article(): self { return $this; } public function section(): self { return $this; } public function p(): string { return 'View Model text for p element here'; } } So in other words: By default, the document structure and the placement of property attributes mainly define the required nesting of view models. Of course there are exceptions to every rule and Templado provides two means to avoid or rather break out of the nesting: By using a prefix or by specifying a resource . Please refer to the respective paragraph for more details on those. Implementing a View Model To be used as a Templado View Model the implementing class generally is not required to fulfill any Templado specific interface, as you might have guessed given the above examples. While that may seem odd from an object-oriented programming perspective, the methods or properties that need to be provided highly depend on the HTML markup and the used RDFa annotations. From Templado's perspective, there is nothing specific enough to require it in terms of an interface. All we need is it to be an object. Note Many templating engines accept nested associative arrays as models, what other programming languages call a dictionary. As PHP unfortunately does not differentiate between lists and dictionaries, it is close to impossible to reliably tell whether the key and its value are supposed to be relevant or should be rather ignored. It was thus a deliberate design decision to not support associative arrays as models. Templado treats everything that is iterable as a list to iterate over, ignoring potential keys and their values. If all you have is an associative array, you could build a simple object wrapper around it using PHP's magic method __get : class ArrayToObjectWrapper { public function __construct(private array $data) {} public function __get(string $key): mixed { if (!array_key_exists($key, $this->data)) { return null; } $value = $this->data[$key]; if (!is_array($value)) { return $value; } if (array_is_list($value)) { return $value; } return new self($value); } } Warning The above wrapper example uses array_is_list to determine whether the array provided is a dictionary or a list. PHP considers an array a list if its keys consist of consecutive numbers from 0 to count($array)-1. This may not apply to your data structure and thus could be unreliable. Understood RDFa Attributes While the RDFa standard contains a lot of attributes, Temoplado only looks for a small subset when performing its rendering work. This section describes which attributes are understood, and what the expected behaviour of the view model is for each. vocab RDFa in HTML is an open standard to semantically enhance markup. To make sense of a set of RDFa nodes, they commonly get semantically grouped into so-called vocabularies. Think of a class or even multiple classes grouping various properties into a meaningful something . This something would be your vocabulary in RDFa's terminology. Of course not all vocabularies are yours and thus most are not relevant for view model rendering. So in case your template contains RDFa attributes from other vocabularies, Templado needs to get told which ones to operate on. Note If you do not include third party vocabularies in your templates, you do not need to set the vocab attribute nor implement support into your view model. Whenever a vocab attribute is encountered while walking down the DOM tree, Templado checks whether the current view model implements a vocab() method. If not, the attribute is ignored. Otherwise, Templado will call the method, passing in the value of the vocab attribute. The return value is expected to be a string that Templado then can compare against the specified vocab - as in, the value of the vocab attribute. If they match, Templado considers the view model to be responsible for this vocabulary and will try to render it. Again, this is probably best understood with an example. A simple HTML fragment, that has a vocab attribute set could look like this: <p vocab=\"https://example.com#book\">Hello world</p> To specify a view model that is considered responsible for this vocabulary, various options exist. All the following examples lead to the same result. class MyRootModel { public function vocab(string $requested): string { return $requested; } } class MyRootModel { public function vocab(): string { return \"https://example.com#book\"; } } class MyRootModel { public string $vocab = \"https://example.com#book\"; } If you want to not have the view model be applied, you have to return a none-matching string. So if the requested vocabulary would for instance be \"https://schema.org\", the last two examples above would already qualify as not being responsible. The first example simply returns the input string and thus would always be considered responsible. The implementation could just as well be removed as it's technically identical to not having a vocab() method at all - but some prefer to make it explicit. property The property annotation is the attribute used to tell Templado to apply or change content - as can be seen to some extent in the examples above already. In general, the value of this attribute is interpreted as the name of the method to be called on the current view model or the name of the public property to be read from it. If the value of this attribute contains a : though, Templado splits the string at the location of the double colon, interpreting the first part as a prefix and the remainder as the method to call or property to access. Given a prefix is set, the current view model context is ignored and the model to operate on is resolved using the found prefix. For this to succeed, the prefix has to have been bound to an object beforehand. Please read the description of prefix to learn more about this feature. When the property annotation resolves to a method call, the current textual value of the context element is passed along by Templado. This allows for simple placeholders to replaced or existing textual content to be extended without having to duplicate it into the view model. Note While the textual content of an element may be technically composed out of various (even nested) markup elements, only their respective text is passed along. E.g. <p>hello <b>world</b> out there!</p> would translate to hello world out there! , effectively stripping any markup contained. Supported Types Templado expects the type of the accessed property or the value returned by a method to be either a string, an array or object - where some object types do have special meaning as listed below. For backwards compatibility, a boolean type is also supported. Returning any other type will cause Templado to throw an exception. String When a string is returned, Templado will replace the current element's content with its value. Be aware that this effectively also removes any other children the current element might have had: <p property=\"templado\">Hello <b>world</b> out there!</p> class StringViewModel { public string $templado = 'Templado'; } <p property=\"templado\">Templado</p> Signal::ignore (or true) Sometimes, Templado needs to be told to skip over an element even though a property attribute had been set and just continue as if none would have been. This can be achieved by returning a Signal::ignore() . For backwards compatibility, a boolean true can also be used. Ignoring an element will not change the current view model context. Signal::remove (or false) To have the current element and thus all its children be removed from the document, a Signal::remove() can be returned. For backwards compatibility, a boolean false can also be used. Removing an element will not change the current view model context. Iterables (e.g. Arrays or Iterator) Iterable types are Templado's equivalent of \"foreach\". The current element will be cloned and the content adjusted for as many times as there are items returned while iterating. Note To preview how for example a list of items would look like, the template document may contain the same element with the same property value multiple times. Templado will extract and clone the first one to copy it as many times as needed while iterating, removing all additional elements with the same property value in the current context. Each iterative call to the view model must either yield a string or new view model object. Direct nesting of iterables or signaling is not supported. View Model Objects *** DOCUMENTATION PENDING *** Operating on HTML Attributes Apart from setting the text content of an element, Templado supports changing the value of or entirely removing existing attributes. Templado will not add new attributes. Note To not break Templado's flow of operation, the supported RDFa attributes are protected and can not be changed or removed using a view model. If you prefer to have RDFa attributes removed at the end of processing, this can be achieved by using a Serializer or Transformation . Supported Types for Attribute Rendering String Signal::ignore (or true) Signal::remove (or false) resource *** DOCUMENTATION PENDING *** prefix *** DOCUMENTATION PENDING *** typeof *** DOCUMENTATION PENDING ***","title":"View Model Rendering"},{"location":"features/view-model/#view-models","text":"","title":"View Models"},{"location":"features/view-model/#introduction","text":"Probably the most essential feature of any templating engine is a means to easily transform a data structure into HTML using, well, a template. There seem to be almost endless ways to define the view logic: From rather limited approaches like merely replacing placeholders, to defining a complete domain specific language. While details of course differ, interestingly enough, most engines seem to agree on embedding the view logic into the template, mixing HTML and custom markup or language constructs into a single file. For rendering, the data is mapped from simple DTOs, xml, json, or - most frequently - associative arrays. These approaches have a tendency to become a mess quickly, being hard to test and to reason about. Wouldn't it be much nicer to have standard HTML files, ready to preview at any time and otherwise controlling the rendering process from outside the template?","title":"Introduction"},{"location":"features/view-model/#using-rdfa","text":"Instead of mixing view logic with markup by embedding instructions into the HTML for a clean separation of concerns, we'd want the logic part to be outside the markup. Yet, for a templating engine to understand how and where to operate, some sort of reference information needs to be provided nevertheless. The best way to do this is by enriching the HTML with structuring metadata, giving the HTML a semantic structure and providing meaning beyond the markup required for a browser to render it: <section property=\"author\"> <h3 property=\"name\">John Doe</h3> <a property=\"email\" typeoOf=\"business\" href=\"mailto:john@example.org\">E-Mail me</a> </section> The above HTML fragment has been annotated with RDFa attributes, a W3C standard to enrich markup with semantic information. In this case, only the property attribute has been used though. When following the tree structure, one can now understand that the text content of the \"h3\" element contains the name of an author and that his business email address is \"john@example.org\". Instead of reinventing the wheel and coming up with a proprietary set of attributes, Templado makes use of these standard attributes to map data from a View Model into the HTML. This is done by calling the relevant method from or by accessing a public property of the given view model. Depending on the returned type, Templado will decide what to do next.","title":"Using RDFa"},{"location":"features/view-model/#how-rendering-works","text":"The view model renderer operates on the internal DOM representation of the template: Starting from the root element - also called DocumentElement -, Templado iterates over all its children and also follows the paths down each respective subtree recursively. Whenever one of the RDFa attributes property , typeof or vocab is encountered, the method associated with it will get called on the current view model. If the returned value for a property triggered call happens to be an object which is not an iterator or generator, it's considered a view model and thus replaces the view model for the current tree position and all their nested elements - until potentially overwritten by yet another view model. This effectively allows for walking down the document tree. This probably is best explained with an example. Let's assume this very basic HTML fragment is our template: <article property=\"article\"> <h1>Article Headline</h1> <section property=\"intro\"> <h2>Headlaine without property attribute</h2> <p property=\"content\">This is the default text</p> </section> </body> The above example contains a html fragment with a nested structure. While there could be any number of elements in between, basically only the property attributes - or rather their respective values - are relevant in this example for the model nesting. Walking down the tree, the nesting is article > intro > content . That means, we initially need a view model we can call article() on. As we're having a nested structure and want to walk down the tree, we need article() to return an object. On the returned object, Templado will call intro() . That's because the next element with a property attribute found while walking down the tree is the section element and the property 's value is \"intro\". Given we want to continue walking the tree, this method should also return an object. We again turn it into a context view model. The next element with a property attribute is the p element. Templado thus calls content() on the current view model, which is the one returned from intro() before. Assuming we want to set the text of the p element, we want that method to return a string. Expressed in PHP code, this could look like this: class MyRootViewModel { public function article(): Article { return new Article(); } } class Article { public function section(): Section { return new Section(); } } class Section { public function p(): string { return 'View Model text for p element here'; } } Given the required methods do not conflict, and we do not have any need for actual view logic other than the nesting, we could - for this very simple example at least - put all this into a single view model class: class MyRootViewModel { public function article(): self { return $this; } public function section(): self { return $this; } public function p(): string { return 'View Model text for p element here'; } } So in other words: By default, the document structure and the placement of property attributes mainly define the required nesting of view models. Of course there are exceptions to every rule and Templado provides two means to avoid or rather break out of the nesting: By using a prefix or by specifying a resource . Please refer to the respective paragraph for more details on those.","title":"How rendering works"},{"location":"features/view-model/#implementing-a-view-model","text":"To be used as a Templado View Model the implementing class generally is not required to fulfill any Templado specific interface, as you might have guessed given the above examples. While that may seem odd from an object-oriented programming perspective, the methods or properties that need to be provided highly depend on the HTML markup and the used RDFa annotations. From Templado's perspective, there is nothing specific enough to require it in terms of an interface. All we need is it to be an object. Note Many templating engines accept nested associative arrays as models, what other programming languages call a dictionary. As PHP unfortunately does not differentiate between lists and dictionaries, it is close to impossible to reliably tell whether the key and its value are supposed to be relevant or should be rather ignored. It was thus a deliberate design decision to not support associative arrays as models. Templado treats everything that is iterable as a list to iterate over, ignoring potential keys and their values. If all you have is an associative array, you could build a simple object wrapper around it using PHP's magic method __get : class ArrayToObjectWrapper { public function __construct(private array $data) {} public function __get(string $key): mixed { if (!array_key_exists($key, $this->data)) { return null; } $value = $this->data[$key]; if (!is_array($value)) { return $value; } if (array_is_list($value)) { return $value; } return new self($value); } } Warning The above wrapper example uses array_is_list to determine whether the array provided is a dictionary or a list. PHP considers an array a list if its keys consist of consecutive numbers from 0 to count($array)-1. This may not apply to your data structure and thus could be unreliable.","title":"Implementing a View Model"},{"location":"features/view-model/#understood-rdfa-attributes","text":"While the RDFa standard contains a lot of attributes, Temoplado only looks for a small subset when performing its rendering work. This section describes which attributes are understood, and what the expected behaviour of the view model is for each.","title":"Understood RDFa Attributes"},{"location":"features/view-model/#vocab","text":"RDFa in HTML is an open standard to semantically enhance markup. To make sense of a set of RDFa nodes, they commonly get semantically grouped into so-called vocabularies. Think of a class or even multiple classes grouping various properties into a meaningful something . This something would be your vocabulary in RDFa's terminology. Of course not all vocabularies are yours and thus most are not relevant for view model rendering. So in case your template contains RDFa attributes from other vocabularies, Templado needs to get told which ones to operate on. Note If you do not include third party vocabularies in your templates, you do not need to set the vocab attribute nor implement support into your view model. Whenever a vocab attribute is encountered while walking down the DOM tree, Templado checks whether the current view model implements a vocab() method. If not, the attribute is ignored. Otherwise, Templado will call the method, passing in the value of the vocab attribute. The return value is expected to be a string that Templado then can compare against the specified vocab - as in, the value of the vocab attribute. If they match, Templado considers the view model to be responsible for this vocabulary and will try to render it. Again, this is probably best understood with an example. A simple HTML fragment, that has a vocab attribute set could look like this: <p vocab=\"https://example.com#book\">Hello world</p> To specify a view model that is considered responsible for this vocabulary, various options exist. All the following examples lead to the same result. class MyRootModel { public function vocab(string $requested): string { return $requested; } } class MyRootModel { public function vocab(): string { return \"https://example.com#book\"; } } class MyRootModel { public string $vocab = \"https://example.com#book\"; } If you want to not have the view model be applied, you have to return a none-matching string. So if the requested vocabulary would for instance be \"https://schema.org\", the last two examples above would already qualify as not being responsible. The first example simply returns the input string and thus would always be considered responsible. The implementation could just as well be removed as it's technically identical to not having a vocab() method at all - but some prefer to make it explicit.","title":"vocab"},{"location":"features/view-model/#property","text":"The property annotation is the attribute used to tell Templado to apply or change content - as can be seen to some extent in the examples above already. In general, the value of this attribute is interpreted as the name of the method to be called on the current view model or the name of the public property to be read from it. If the value of this attribute contains a : though, Templado splits the string at the location of the double colon, interpreting the first part as a prefix and the remainder as the method to call or property to access. Given a prefix is set, the current view model context is ignored and the model to operate on is resolved using the found prefix. For this to succeed, the prefix has to have been bound to an object beforehand. Please read the description of prefix to learn more about this feature. When the property annotation resolves to a method call, the current textual value of the context element is passed along by Templado. This allows for simple placeholders to replaced or existing textual content to be extended without having to duplicate it into the view model. Note While the textual content of an element may be technically composed out of various (even nested) markup elements, only their respective text is passed along. E.g. <p>hello <b>world</b> out there!</p> would translate to hello world out there! , effectively stripping any markup contained.","title":"property"},{"location":"features/view-model/#supported-types","text":"Templado expects the type of the accessed property or the value returned by a method to be either a string, an array or object - where some object types do have special meaning as listed below. For backwards compatibility, a boolean type is also supported. Returning any other type will cause Templado to throw an exception.","title":"Supported Types"},{"location":"features/view-model/#string","text":"When a string is returned, Templado will replace the current element's content with its value. Be aware that this effectively also removes any other children the current element might have had: <p property=\"templado\">Hello <b>world</b> out there!</p> class StringViewModel { public string $templado = 'Templado'; } <p property=\"templado\">Templado</p>","title":"String"},{"location":"features/view-model/#signalignore-or-true","text":"Sometimes, Templado needs to be told to skip over an element even though a property attribute had been set and just continue as if none would have been. This can be achieved by returning a Signal::ignore() . For backwards compatibility, a boolean true can also be used. Ignoring an element will not change the current view model context.","title":"Signal::ignore (or true)"},{"location":"features/view-model/#signalremove-or-false","text":"To have the current element and thus all its children be removed from the document, a Signal::remove() can be returned. For backwards compatibility, a boolean false can also be used. Removing an element will not change the current view model context.","title":"Signal::remove (or false)"},{"location":"features/view-model/#iterables-eg-arrays-or-iterator","text":"Iterable types are Templado's equivalent of \"foreach\". The current element will be cloned and the content adjusted for as many times as there are items returned while iterating. Note To preview how for example a list of items would look like, the template document may contain the same element with the same property value multiple times. Templado will extract and clone the first one to copy it as many times as needed while iterating, removing all additional elements with the same property value in the current context. Each iterative call to the view model must either yield a string or new view model object. Direct nesting of iterables or signaling is not supported.","title":"Iterables (e.g. Arrays or Iterator)"},{"location":"features/view-model/#view-model-objects","text":"*** DOCUMENTATION PENDING ***","title":"View Model Objects"},{"location":"features/view-model/#operating-on-html-attributes","text":"Apart from setting the text content of an element, Templado supports changing the value of or entirely removing existing attributes. Templado will not add new attributes. Note To not break Templado's flow of operation, the supported RDFa attributes are protected and can not be changed or removed using a view model. If you prefer to have RDFa attributes removed at the end of processing, this can be achieved by using a Serializer or Transformation .","title":"Operating on HTML Attributes"},{"location":"features/view-model/#supported-types-for-attribute-rendering","text":"String Signal::ignore (or true) Signal::remove (or false)","title":"Supported Types for Attribute Rendering"},{"location":"features/view-model/#resource","text":"*** DOCUMENTATION PENDING ***","title":"resource"},{"location":"features/view-model/#prefix","text":"*** DOCUMENTATION PENDING ***","title":"prefix"},{"location":"features/view-model/#typeof","text":"*** DOCUMENTATION PENDING ***","title":"typeof"},{"location":"migrate/templado4/","text":"Migration from Templado 4.x In general, migrating from Templado 4.x to Templado 5.0 should be pretty straight forward. The general concepts as well as APIs are mostly kept identical or got enhanced in a backwards compatible way. The main changes are: Requires PHP 8.2+ Templado 5.0 is quite a bit faster than 4.x HTML and Snippet got logically merged into a Document , representing both types A new HTMLSerializer has been introduced to generate HTML 5 output ViewModels now can have public properties to satisfy the rendering needs return a signal instance rather than relying on bool types Form data handling now supports nested structures as well as fields referenced by id A Selector can now be used in more cases to specify what areas of a document to apply the change to Optionally vocab aware Enhanced trace output in case of errors Snapshot support The following paragraphs gives more in-depth details on these changes. Updated and Changed Requirements In contrast to Templado 4, which was designed to work with PHP 7+, Templado 5 requires PHP 8.2 and later. Additionally, as Templado 5 ships with an enhanced custom HTML 5 Serializer implementation, a new requirement to ext/xmlwriter has been added. Loading Facade Templado removed In Templado 4.x and earlier, a facade named Templado existed providing static factory methods to create HTML instances from files or strings. This extra facade was deemed superfluous and got removed. It's functionality got, in part, replaced by Document::fromString . Templado 5 no longer performs any file loading operations itself, so the class FileName got removed. This means the following calls would need to get changed from $html1 = Templado::loadHTMLFile(new FileName(...)); $html2 = Templado::parseHtmlString(...); to $html1 = Document::fromString(file_get_contents(...)); $html2 = Document::fromString(...); This should be a simple search-and-replace refactoring. Dealing with potential parse errors As Templado 5 does no longer provide a loading facade, the respective exceptions are also gone. If you want to catch any issues with parsing when using the Document::fromString method you can now explicitly catch Templado\\Engine\\ParsingException rather than the old rather generic TempladoException . To learn the details on what actually went wrong, you can ask the exception instance object for the LibXMLError instances using Templado\\Engine\\ParsingException::errors() . Everything is a Document now In Templado 4.x and earlier, every rendering operation could be applied on a document using the HTML facade object - optionally created by the aforementioned factory facade. To support merging fragments into documents, the concept of so-called snippets existed, represented by multiple types of Snippet classes. In a nutshell, these merely served as a glorified transfer object and implemented different strategies on how the merge should be performed. This concept turned out to be rather impractical, hard to understand and limiting in practical use, so for Templado 5, the concept of a snippet being different from an HTML document got dropped. Everything is now a Document , regardless whether it represents a complete HTML structure or merely a fragment. Accordingly, throught a code base using Templado 4, all type declarations need to get changed from HTML or Snippet to Document . Migrating Snippets To migrate from Templado 4, all explicit calls to load or instantiate a Snippet need to get replaced by calls to Document and the best matching factory method. As already mentioned, Templado no longer performs filesystem operations itself. This means, the previously existing SnippetLoader used in the following example to create $snippet3 has been removed: $snippet1 = new \\Templado\\Engine\\SimpleSnippet('some-id', $dom); $snippet2 = new \\Templado\\Engine\\TempladoSnippet('some-id', $dom); $snippet3 = (new SnippetLoader)->load(new FileName('...'), 'optionally-id-here'); For merging of documents (or previously snippets), the to-be-merged objects must have an ID set. To ensure the syntactical validity according to W3C rules, a new value object Id got introduced and replaces the scalar string type used before. Note In Templado 4 when using the SnippetLoader , providing an ID was optional. If none was given, Templado's loader implementation checked whether an ID was set as an attribute on the root element within the loaded document and extracted it from there. As the loader functionality got removed, this is technically no longer possible. The implicit assignment of the ID from content was confusing at best, and, unfortunately, a common source for errors. The above code examples should thus be replaced as follows: $snippet1 = \\Templado\\Engine\\Document::fromDomDocument($dom, new Id('some-id')); $snippet2 = \\Templado\\Engine\\Document::fromDomDocument($dom, new Id('some-id')); $snippet3 = \\Templado\\Engine\\Document::fromString( file_get_contents('...'), new Id('no-longer-optional-id-here') ); TODO HTML::applySnippets => Document::merge SnippetListCollection => DocumentCollection SnippetListCollection::addSnippet => DocumentCollection::add Transformation::getSelector => Transformation::selector Namespace of snippets wrapper document: snippet : https://templado.io/snippet/1.0 => document : https://templado.io/document/1.0 HTML::asString() => Document::asString(new HTMLSerializer)","title":"Templado 4.x"},{"location":"migrate/templado4/#migration-from-templado-4x","text":"In general, migrating from Templado 4.x to Templado 5.0 should be pretty straight forward. The general concepts as well as APIs are mostly kept identical or got enhanced in a backwards compatible way. The main changes are: Requires PHP 8.2+ Templado 5.0 is quite a bit faster than 4.x HTML and Snippet got logically merged into a Document , representing both types A new HTMLSerializer has been introduced to generate HTML 5 output ViewModels now can have public properties to satisfy the rendering needs return a signal instance rather than relying on bool types Form data handling now supports nested structures as well as fields referenced by id A Selector can now be used in more cases to specify what areas of a document to apply the change to Optionally vocab aware Enhanced trace output in case of errors Snapshot support The following paragraphs gives more in-depth details on these changes.","title":"Migration from Templado 4.x"},{"location":"migrate/templado4/#updated-and-changed-requirements","text":"In contrast to Templado 4, which was designed to work with PHP 7+, Templado 5 requires PHP 8.2 and later. Additionally, as Templado 5 ships with an enhanced custom HTML 5 Serializer implementation, a new requirement to ext/xmlwriter has been added.","title":"Updated and Changed Requirements"},{"location":"migrate/templado4/#loading-facade-templado-removed","text":"In Templado 4.x and earlier, a facade named Templado existed providing static factory methods to create HTML instances from files or strings. This extra facade was deemed superfluous and got removed. It's functionality got, in part, replaced by Document::fromString . Templado 5 no longer performs any file loading operations itself, so the class FileName got removed. This means the following calls would need to get changed from $html1 = Templado::loadHTMLFile(new FileName(...)); $html2 = Templado::parseHtmlString(...); to $html1 = Document::fromString(file_get_contents(...)); $html2 = Document::fromString(...); This should be a simple search-and-replace refactoring.","title":"Loading Facade Templado removed"},{"location":"migrate/templado4/#dealing-with-potential-parse-errors","text":"As Templado 5 does no longer provide a loading facade, the respective exceptions are also gone. If you want to catch any issues with parsing when using the Document::fromString method you can now explicitly catch Templado\\Engine\\ParsingException rather than the old rather generic TempladoException . To learn the details on what actually went wrong, you can ask the exception instance object for the LibXMLError instances using Templado\\Engine\\ParsingException::errors() .","title":"Dealing with potential parse errors"},{"location":"migrate/templado4/#everything-is-a-document-now","text":"In Templado 4.x and earlier, every rendering operation could be applied on a document using the HTML facade object - optionally created by the aforementioned factory facade. To support merging fragments into documents, the concept of so-called snippets existed, represented by multiple types of Snippet classes. In a nutshell, these merely served as a glorified transfer object and implemented different strategies on how the merge should be performed. This concept turned out to be rather impractical, hard to understand and limiting in practical use, so for Templado 5, the concept of a snippet being different from an HTML document got dropped. Everything is now a Document , regardless whether it represents a complete HTML structure or merely a fragment. Accordingly, throught a code base using Templado 4, all type declarations need to get changed from HTML or Snippet to Document .","title":"Everything is a Document now"},{"location":"migrate/templado4/#migrating-snippets","text":"To migrate from Templado 4, all explicit calls to load or instantiate a Snippet need to get replaced by calls to Document and the best matching factory method. As already mentioned, Templado no longer performs filesystem operations itself. This means, the previously existing SnippetLoader used in the following example to create $snippet3 has been removed: $snippet1 = new \\Templado\\Engine\\SimpleSnippet('some-id', $dom); $snippet2 = new \\Templado\\Engine\\TempladoSnippet('some-id', $dom); $snippet3 = (new SnippetLoader)->load(new FileName('...'), 'optionally-id-here'); For merging of documents (or previously snippets), the to-be-merged objects must have an ID set. To ensure the syntactical validity according to W3C rules, a new value object Id got introduced and replaces the scalar string type used before. Note In Templado 4 when using the SnippetLoader , providing an ID was optional. If none was given, Templado's loader implementation checked whether an ID was set as an attribute on the root element within the loaded document and extracted it from there. As the loader functionality got removed, this is technically no longer possible. The implicit assignment of the ID from content was confusing at best, and, unfortunately, a common source for errors. The above code examples should thus be replaced as follows: $snippet1 = \\Templado\\Engine\\Document::fromDomDocument($dom, new Id('some-id')); $snippet2 = \\Templado\\Engine\\Document::fromDomDocument($dom, new Id('some-id')); $snippet3 = \\Templado\\Engine\\Document::fromString( file_get_contents('...'), new Id('no-longer-optional-id-here') );","title":"Migrating Snippets"},{"location":"migrate/templado4/#todo","text":"HTML::applySnippets => Document::merge SnippetListCollection => DocumentCollection SnippetListCollection::addSnippet => DocumentCollection::add Transformation::getSelector => Transformation::selector Namespace of snippets wrapper document: snippet : https://templado.io/snippet/1.0 => document : https://templado.io/document/1.0 HTML::asString() => Document::asString(new HTMLSerializer)","title":"TODO"}]}