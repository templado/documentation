{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Templado Documentation Last Updated: 2023-09-05 Most of today's templating engines mix code for the required rendering logic with HTML markup in one file and require developers to learn their respective language as well as syntax. \u00bbFinally a template engine that does not require learning a new language or syntax.\u00ab Templado follows a different approach on templating: Being in part inspired by Tempan , Templado's main feature - the template rendering - relies solely on plain and standard HTML markup with a subset of RDFa annotations. The limited amount of display logic required is contained within the engine and triggered by the view model or form when being applied to the document. Templado is Open Source, licensed under the BSD 3-Clause License . This documentation covers Templado 5.0 Please follow this link for documentation on Templado 4.x","title":"Templado Documentation"},{"location":"#templado-documentation","text":"Last Updated: 2023-09-05 Most of today's templating engines mix code for the required rendering logic with HTML markup in one file and require developers to learn their respective language as well as syntax.","title":"Templado Documentation"},{"location":"#finally-a-template-engine-that-does-not-require-learning-a-new-language-or-syntax","text":"Templado follows a different approach on templating: Being in part inspired by Tempan , Templado's main feature - the template rendering - relies solely on plain and standard HTML markup with a subset of RDFa annotations. The limited amount of display logic required is contained within the engine and triggered by the view model or form when being applied to the document. Templado is Open Source, licensed under the BSD 3-Clause License .","title":"\u00bbFinally a template engine that does not require learning a new language or syntax.\u00ab"},{"location":"#this-documentation-covers-templado-50please-follow-this-link-for-documentation-on-templado-4x","text":"","title":"This documentation covers Templado 5.0Please follow this link for documentation on Templado 4.x"},{"location":"first-steps/","text":"Getting Started As with any templating engine, the main goal is to pair a template with a data source. Templado uses View Models and HTML templates to accomplish this. So the first thing we need to do is introduce them to each other. 1. Loading the Template For Templado to operate, we need a Template to work with. From Templado's point of view, every Template is a Document . This can either be a complete HTML page - or just a fragment or snippet. A Templado Document can be instantiated either from a string or by supplying an already created instance of PHP's DOMDocument . For our first steps, we'll be using a String: $document = Templado\\Engine\\Document::fromString(' <!DOCTYPE html> <html lang=\"en\"> <head> <title>Hello World, Templado!</title> </head> <body> <h1 property=\"headline\">My First Template</h1> </body> </html> '); Note While HTML can be represented using either the HTML or the XML serialization format, LibXML 2.x - the underlying engine that powers most of PHP's DOM support - does only support the HTML serialization format up to version 4. For that reason, and to avoid other quirks, Templado uses the XML mode when parsing a string. If you do not want this, feel free to create a DOMDocument by other means and pass that to Templado using the alternative factory method Templado\\Engine\\Document::fromDomDocument . 2. Applying a View Model Once a Document instance is available, a View Model can be applied. Templado relies on RDFa attributes embedded into the HTML to determine which methods to call on the current view model. More details on this, supported attributes and their respective meaning for Templado as well as more complex constructs can be found in the View Models section. The above basic HTML example contains a single RDFa attribute property . Templado uses this attribute, or rather the value of it, as the method name to call on the current view model and to determine what to do. The application of a very basic view Model to change text of the <h1> element could look like this: $document->applyViewModel(new class { public function headline(): string { return 'Hello world!'; } }); The property 's value is \"headline\", thus Templado is going to call the method named \"headline\" on the view model. Given the returned type is a string , the element's text content will be changed. 3. Serializing back to HTML Given the above sample model, Templado will replace the original text ('My First Template') with 'Hello world!'. To verify our success, we can have Templado serialize the Document back to HTML for us. We'll do so by using Templado's HTML Serializer. More on the serializer support can be found in the Serializer section. The HTML Serializer used here will ensure we produce sane HTML 5 output, despite the fact we use the XML mode internally: print $document->asString( new Templado\\Engine\\HTMLSerializer() ); The above should produce this output: <!DOCTYPE html> <html lang=\"en\"> <head> <title>Hello World, Templado!</title> </head> <body> <h1 property=\"headline\">Hello world!</h1> </body> </html> Congratulations, you just rendered your first HTML page using Templado!","title":"First Steps"},{"location":"first-steps/#getting-started","text":"As with any templating engine, the main goal is to pair a template with a data source. Templado uses View Models and HTML templates to accomplish this. So the first thing we need to do is introduce them to each other.","title":"Getting Started"},{"location":"first-steps/#1-loading-the-template","text":"For Templado to operate, we need a Template to work with. From Templado's point of view, every Template is a Document . This can either be a complete HTML page - or just a fragment or snippet. A Templado Document can be instantiated either from a string or by supplying an already created instance of PHP's DOMDocument . For our first steps, we'll be using a String: $document = Templado\\Engine\\Document::fromString(' <!DOCTYPE html> <html lang=\"en\"> <head> <title>Hello World, Templado!</title> </head> <body> <h1 property=\"headline\">My First Template</h1> </body> </html> '); Note While HTML can be represented using either the HTML or the XML serialization format, LibXML 2.x - the underlying engine that powers most of PHP's DOM support - does only support the HTML serialization format up to version 4. For that reason, and to avoid other quirks, Templado uses the XML mode when parsing a string. If you do not want this, feel free to create a DOMDocument by other means and pass that to Templado using the alternative factory method Templado\\Engine\\Document::fromDomDocument .","title":"1. Loading the Template"},{"location":"first-steps/#2-applying-a-view-model","text":"Once a Document instance is available, a View Model can be applied. Templado relies on RDFa attributes embedded into the HTML to determine which methods to call on the current view model. More details on this, supported attributes and their respective meaning for Templado as well as more complex constructs can be found in the View Models section. The above basic HTML example contains a single RDFa attribute property . Templado uses this attribute, or rather the value of it, as the method name to call on the current view model and to determine what to do. The application of a very basic view Model to change text of the <h1> element could look like this: $document->applyViewModel(new class { public function headline(): string { return 'Hello world!'; } }); The property 's value is \"headline\", thus Templado is going to call the method named \"headline\" on the view model. Given the returned type is a string , the element's text content will be changed.","title":"2. Applying a View Model"},{"location":"first-steps/#3-serializing-back-to-html","text":"Given the above sample model, Templado will replace the original text ('My First Template') with 'Hello world!'. To verify our success, we can have Templado serialize the Document back to HTML for us. We'll do so by using Templado's HTML Serializer. More on the serializer support can be found in the Serializer section. The HTML Serializer used here will ensure we produce sane HTML 5 output, despite the fact we use the XML mode internally: print $document->asString( new Templado\\Engine\\HTMLSerializer() ); The above should produce this output: <!DOCTYPE html> <html lang=\"en\"> <head> <title>Hello World, Templado!</title> </head> <body> <h1 property=\"headline\">Hello world!</h1> </body> </html> Congratulations, you just rendered your first HTML page using Templado!","title":"3. Serializing back to HTML"},{"location":"install/","text":"Installation Runtime Requirements Templado merely requires an up-to-date PHP Version with XML and DOM support. So this boils down to the following: PHP >= 8.2.0 Extensions dom libxml Note Please note that when you want to contribute to the development of Templado or if you just want to run the tests or some of the tools used during development of Templado like infection or psalm, additional extensions are required. As this is not a runtime requirement, those are not listed here. Install with Composer Templado is designed to be installed as a library using Composer , the defacto standard to install and manage runtime dependencies for PHP. The easiest way to add Templado to your project is from the CLI: $ composer require templado/engine:^5.0 If you prefer to manually create or edit the composer.json file, please add the following fragment to it. \"require\" : { \"templado/engine\": \"^5.0\" } For Templado, and its dependencies, to be actually installed after manually editing, you'd have to explicitly run composer install . Manual Installation If you do not want to or cannot use Composer for some reason, a manual installation is of course also possible. Keep in mind that you are fully responsible to manage a potential upgrade, dependency resoling and autoloading. If you still insist on a manual installation, feel free to clone the source repository, and switch to whatever is the latest 5.x release tag. For instance: git clone git@github.com:templado/engine.git && cd engine && git switch 5.x.y For the CSSSelector to work, you need to additionally install theseer\\css2xpath : git clone git@github.com:theseer/css2xpath.git Note As you opted for not using Composer, no autoloader has been generated yet. Please update your autoloader accordingly, so the newly installed classes and interfaces can be found. Warning While of course technically possible, using a manual installation is not supported. If you run into any issues with Templado, please ensure the problem is reproducible using a composer based installation before reporting it.","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#runtime-requirements","text":"Templado merely requires an up-to-date PHP Version with XML and DOM support. So this boils down to the following: PHP >= 8.2.0 Extensions dom libxml Note Please note that when you want to contribute to the development of Templado or if you just want to run the tests or some of the tools used during development of Templado like infection or psalm, additional extensions are required. As this is not a runtime requirement, those are not listed here.","title":"Runtime Requirements"},{"location":"install/#install-with-composer","text":"Templado is designed to be installed as a library using Composer , the defacto standard to install and manage runtime dependencies for PHP. The easiest way to add Templado to your project is from the CLI: $ composer require templado/engine:^5.0 If you prefer to manually create or edit the composer.json file, please add the following fragment to it. \"require\" : { \"templado/engine\": \"^5.0\" } For Templado, and its dependencies, to be actually installed after manually editing, you'd have to explicitly run composer install .","title":"Install with Composer"},{"location":"install/#manual-installation","text":"If you do not want to or cannot use Composer for some reason, a manual installation is of course also possible. Keep in mind that you are fully responsible to manage a potential upgrade, dependency resoling and autoloading. If you still insist on a manual installation, feel free to clone the source repository, and switch to whatever is the latest 5.x release tag. For instance: git clone git@github.com:templado/engine.git && cd engine && git switch 5.x.y For the CSSSelector to work, you need to additionally install theseer\\css2xpath : git clone git@github.com:theseer/css2xpath.git Note As you opted for not using Composer, no autoloader has been generated yet. Please update your autoloader accordingly, so the newly installed classes and interfaces can be found. Warning While of course technically possible, using a manual installation is not supported. If you run into any issues with Templado, please ensure the problem is reproducible using a composer based installation before reporting it.","title":"Manual Installation"},{"location":"extend/filters/","text":"","title":"Creating Filters"},{"location":"extend/selectors/","text":"","title":"Creating Selectors"},{"location":"extend/serializers/","text":"","title":"Custom Serialization"},{"location":"extend/transformations/","text":"","title":"Creating Transformations"},{"location":"features/form-handling/","text":"","title":"Form Handling"},{"location":"features/merge/","text":"","title":"Merging Documents"},{"location":"features/serializing/","text":"","title":"Controlling the Serializing"},{"location":"features/transformation/","text":"","title":"Applying Transformations"},{"location":"features/view-model/","text":"View Models Introduction Probably the most essential feature of any templating engine is a means to easily transform a data structure into HTML using, well, a template. There seem to be almost endless ways to define the view logic: From rather limited approaches like merely replacing placeholders, to defining a complete domain specific language. While details of course differ, interestingly enough, most engines seem to agree on embedding the view logic into the template, mixing HTML and custom markup or language constructs into a single file. For rendering, the data is mapped from simple DTOs, xml, json, or - most frequently - associative arrays. These approaches have a tendency to become a mess quickly, being hard to test and to reason about. Wouldn't it be much nicer to have standard HTML files, ready to preview at any time and otherwise controlling the rendering process from outside the template? Using RDFa Instead of mixing view logic with markup by embedding instructions into the HTML for a clean separation of concerns, we'd want the logic part to be outside the markup. Yet, for a templating engine to understand how and where to operate, some sort of reference information needs to be provided nevertheless. The best way to do this is by enriching the HTML with structuring metadata, giving the HTML a semantic structure and providing meaning beyond the markup required for a browser to render it: <section property=\"author\"> <h3 property=\"name\">John Doe</h3> <a property=\"email\" typeoOf=\"business\" href=\"mailto:john@example.org\">E-Mail me</a> </section> The above HTML fragment has been annotated with RDFa attributes. In this case, only the property attribute has been used though. When following the tree structure, one can now understand that the text content of the \"h3\" element contains the name of an author and that his business email address is \"john@example.org\". Instead of reinventing the wheel and coming up with a proprietary set of attributes, Templado makes use of these attributes to map data from a View Model into the HTML. This is done by calling the relevant method from or by accessing a public property of the given view model. Depending on the returned type, Templado will decide what to do next. How rendering works The view model renderer operates on the internal DOM representation of the template: Starting from the root element - also called DocumentElement -, Templado iterates over all its children and also follows the paths down each respective subtree recursively. Whenever one of the RDFa attributes vocab , property or typeof is encountered, the method associated with it will get called on the current view model context. If the returned value for a property triggered call happens to be an object, it's considered a view model and thus replaces the view model for the current tree position and all their nested elements - until potentially overwritten by yet another view model. This effectively allows for walking down the document tree. This probably is best explained with an example. Let's assume this very basic HTML fragment is our template: <article property=\"article\"> <h1>Article Headline</h1> <section property=\"intro\"> <h2>Headlaine without property attribute</h2> <p property=\"content\">This is the default text</p> </section> </body> The above example contains a html fragment with a nested structure. While there could be any number of elements in between, basically only the property attributes - or rather their respective values - are relevant in this example for the model nesting. Walking down the tree, the nesting is article > intro > content . That means, we initially need a view model we can call article() on. As we're having a nested structure and want to walk down the tree, we need article() to return an object. On the returned object, Templado will call intro() . That's because the next element with a property attribute found while walking down the tree is the section element and the property 's value is \"intro\". Given we want to continue walking the tree, this method should also return an object. We again turn it into a context view model. The next element with a property attribute is the p element. Templado thus calls content() on the current view model, which is the one returned from intro() before. Assuming we want to set the text of the p element, we want that method to return a string. Expressed in PHP code, this could look like this: class MyRootViewModel { public function article(): Article { return new Article(); } } class Article { public function section(): Section { return new Section(); } } class Section { public function p(): string { return 'View Model text for p element here'; } } Given the required methods do not conflict, and we do not have any need for actual view logic other than the nesting, we could - for this very simple example at least - put all this into a single view model class: class MyRootViewModel { public function article(): self { return $this; } public function section(): self { return $this; } public function p(): string { return 'View Model text for p element here'; } } So in other words: By default, the document structure and the placement of property attributes mainly define the required nesting of view models. Of course there are exceptions to every rule and Templado provides two means to avoid or rather break out of the nesting: By using a prefix or by specifying a resource . Please refer to the respective paragraph for more details on those. Implementing a View Model To be used as a Templado View Model the implementing class generally is not required to fulfill any Templado specific interface, as you might have guessed given the above examples. While that may seem odd from an object-oriented programming perspective, the methods or properties that need to be provided highly depend on the HTML markup and the used RDFa annotations. From Templado's perspective, there is nothing specific enough to require it in terms of an interface. All we need is it to be an object. Note Many templating engines accept nested associative arrays as models, what other programming languages call a dictionary. As PHP unfortunately does not differentiate between lists and dictionaries, it is close to impossible to reliably tell whether the key and its value are supposed to be relevant or should be rather ignored. It was thus a deliberate design decision to not support associative arrays as models. Templado treats everything that is iterable as a list to iterate over, ignoring potential keys and their values. If all you have is an associative array, you could build a simple object wrapper around it using PHP's magic method __get : class ArrayToObjectWrapper { public function __construct(private array $data) {} public function __get(string $key): mixed { if (!array_key_exists($key, $this->data)) { return null; } $value = $this->data[$key]; if (!is_array($value)) { return $value; } if (array_is_list($value)) { return $value; } return new self($value); } } Warning The above wrapper example uses array_is_list to determine whether the array provided is a dictionary or a list. PHP considers an array a list if its keys consist of consecutive numbers from 0 to count($array)-1. This may not apply to your data structure and thus could be unreliable. Understood RDFa Attributes While the RDFa standard contains a lot of attributes, Temoplado only looks for a small subset when performing its rendering work. This section describes which attributes are understood, and what the expected behaviour of the view model is for each. vocab RDFa in HTML is an open standard to semantically enhance markup. To make sense of a set of RDFa nodes, they commonly get semantically grouped into so-called vocabularies. Think of a class or even multiple classes grouping various properties into a meaningful something . This something would be your vocabulary in RDFa's terminology. Of course not all vocabularies are yours and thus most are not relevant for view model rendering. So in case your template contains RDFa attributes from other vocabularies, Templado needs to get told which ones to operate on. Note If you do not include third party vocabularies in your templates, you do not need to set the vocab attribute nor implement support into your view model. Whenever a vocab attribute is encountered while walking down the DOM tree, Templado checks whether the current view model implements a vocab() method. If not, the attribute is ignored. Otherwise, Templado will call the method, passing in the value of the vocab attribute. The return value is expected to be a string that Templado then can compare against the specified vocab - as in, the value of the vocab attribute. If they match, Templado considers the view model to be responsible for this vocabulary and will try to render it. Again, this is probably best understood with an example. A simple HTML fragment, that has a vocab attribute set could look like this: <p vocab=\"https://example.com#book\">Hello world</p> To specify a view model that is considered responsible for this vocabulary, various options exist. All the following examples lead to the same result. class MyRootModel { public function vocab(string $requested): string { return $requested; } } class MyRootModel { public function vocab(): string { return \"https://example.com#book\"; } } class MyRootModel { public string $vocab = \"https://example.com#book\"; } If you want to not have the view model be applied, you have to return a none-matching string. So if the requested vocabulary would for instance be \"https://schema.org\", the last two examples above would already qualify as not being responsible. The first example simply returns the input string and thus would always be considered responsible. The implementation could just as well be removed as it's technically identical to not having a vocab() method at all - but some prefer to make it explicit. property Supported Return Types String Signal::ignore (or true) Signal::remove (or false) Iterables (e.g. Arrays or Iterator) View Model Objects Operating on HTML Attributes Apart from setting the text content of an element, Templado supports changing the value of or entirely removing existing attributes. Templado will not add new attributes. Note To not break Templado's flow of operation, the supported RDFa attributes are protected and can not be changed or removed using a view model. If you prefer to have RDFa attributes removed at the end of processing, this can be achieved by using the Serliazer . Supported Types for Attribute Rendering # String # Signal::ignore (or true) # Signal::remove (or false) resource prefix typeof","title":"View Model Rendering"},{"location":"features/view-model/#view-models","text":"","title":"View Models"},{"location":"features/view-model/#introduction","text":"Probably the most essential feature of any templating engine is a means to easily transform a data structure into HTML using, well, a template. There seem to be almost endless ways to define the view logic: From rather limited approaches like merely replacing placeholders, to defining a complete domain specific language. While details of course differ, interestingly enough, most engines seem to agree on embedding the view logic into the template, mixing HTML and custom markup or language constructs into a single file. For rendering, the data is mapped from simple DTOs, xml, json, or - most frequently - associative arrays. These approaches have a tendency to become a mess quickly, being hard to test and to reason about. Wouldn't it be much nicer to have standard HTML files, ready to preview at any time and otherwise controlling the rendering process from outside the template?","title":"Introduction"},{"location":"features/view-model/#using-rdfa","text":"Instead of mixing view logic with markup by embedding instructions into the HTML for a clean separation of concerns, we'd want the logic part to be outside the markup. Yet, for a templating engine to understand how and where to operate, some sort of reference information needs to be provided nevertheless. The best way to do this is by enriching the HTML with structuring metadata, giving the HTML a semantic structure and providing meaning beyond the markup required for a browser to render it: <section property=\"author\"> <h3 property=\"name\">John Doe</h3> <a property=\"email\" typeoOf=\"business\" href=\"mailto:john@example.org\">E-Mail me</a> </section> The above HTML fragment has been annotated with RDFa attributes. In this case, only the property attribute has been used though. When following the tree structure, one can now understand that the text content of the \"h3\" element contains the name of an author and that his business email address is \"john@example.org\". Instead of reinventing the wheel and coming up with a proprietary set of attributes, Templado makes use of these attributes to map data from a View Model into the HTML. This is done by calling the relevant method from or by accessing a public property of the given view model. Depending on the returned type, Templado will decide what to do next.","title":"Using RDFa"},{"location":"features/view-model/#how-rendering-works","text":"The view model renderer operates on the internal DOM representation of the template: Starting from the root element - also called DocumentElement -, Templado iterates over all its children and also follows the paths down each respective subtree recursively. Whenever one of the RDFa attributes vocab , property or typeof is encountered, the method associated with it will get called on the current view model context. If the returned value for a property triggered call happens to be an object, it's considered a view model and thus replaces the view model for the current tree position and all their nested elements - until potentially overwritten by yet another view model. This effectively allows for walking down the document tree. This probably is best explained with an example. Let's assume this very basic HTML fragment is our template: <article property=\"article\"> <h1>Article Headline</h1> <section property=\"intro\"> <h2>Headlaine without property attribute</h2> <p property=\"content\">This is the default text</p> </section> </body> The above example contains a html fragment with a nested structure. While there could be any number of elements in between, basically only the property attributes - or rather their respective values - are relevant in this example for the model nesting. Walking down the tree, the nesting is article > intro > content . That means, we initially need a view model we can call article() on. As we're having a nested structure and want to walk down the tree, we need article() to return an object. On the returned object, Templado will call intro() . That's because the next element with a property attribute found while walking down the tree is the section element and the property 's value is \"intro\". Given we want to continue walking the tree, this method should also return an object. We again turn it into a context view model. The next element with a property attribute is the p element. Templado thus calls content() on the current view model, which is the one returned from intro() before. Assuming we want to set the text of the p element, we want that method to return a string. Expressed in PHP code, this could look like this: class MyRootViewModel { public function article(): Article { return new Article(); } } class Article { public function section(): Section { return new Section(); } } class Section { public function p(): string { return 'View Model text for p element here'; } } Given the required methods do not conflict, and we do not have any need for actual view logic other than the nesting, we could - for this very simple example at least - put all this into a single view model class: class MyRootViewModel { public function article(): self { return $this; } public function section(): self { return $this; } public function p(): string { return 'View Model text for p element here'; } } So in other words: By default, the document structure and the placement of property attributes mainly define the required nesting of view models. Of course there are exceptions to every rule and Templado provides two means to avoid or rather break out of the nesting: By using a prefix or by specifying a resource . Please refer to the respective paragraph for more details on those.","title":"How rendering works"},{"location":"features/view-model/#implementing-a-view-model","text":"To be used as a Templado View Model the implementing class generally is not required to fulfill any Templado specific interface, as you might have guessed given the above examples. While that may seem odd from an object-oriented programming perspective, the methods or properties that need to be provided highly depend on the HTML markup and the used RDFa annotations. From Templado's perspective, there is nothing specific enough to require it in terms of an interface. All we need is it to be an object. Note Many templating engines accept nested associative arrays as models, what other programming languages call a dictionary. As PHP unfortunately does not differentiate between lists and dictionaries, it is close to impossible to reliably tell whether the key and its value are supposed to be relevant or should be rather ignored. It was thus a deliberate design decision to not support associative arrays as models. Templado treats everything that is iterable as a list to iterate over, ignoring potential keys and their values. If all you have is an associative array, you could build a simple object wrapper around it using PHP's magic method __get : class ArrayToObjectWrapper { public function __construct(private array $data) {} public function __get(string $key): mixed { if (!array_key_exists($key, $this->data)) { return null; } $value = $this->data[$key]; if (!is_array($value)) { return $value; } if (array_is_list($value)) { return $value; } return new self($value); } } Warning The above wrapper example uses array_is_list to determine whether the array provided is a dictionary or a list. PHP considers an array a list if its keys consist of consecutive numbers from 0 to count($array)-1. This may not apply to your data structure and thus could be unreliable.","title":"Implementing a View Model"},{"location":"features/view-model/#understood-rdfa-attributes","text":"While the RDFa standard contains a lot of attributes, Temoplado only looks for a small subset when performing its rendering work. This section describes which attributes are understood, and what the expected behaviour of the view model is for each.","title":"Understood RDFa Attributes"},{"location":"features/view-model/#vocab","text":"RDFa in HTML is an open standard to semantically enhance markup. To make sense of a set of RDFa nodes, they commonly get semantically grouped into so-called vocabularies. Think of a class or even multiple classes grouping various properties into a meaningful something . This something would be your vocabulary in RDFa's terminology. Of course not all vocabularies are yours and thus most are not relevant for view model rendering. So in case your template contains RDFa attributes from other vocabularies, Templado needs to get told which ones to operate on. Note If you do not include third party vocabularies in your templates, you do not need to set the vocab attribute nor implement support into your view model. Whenever a vocab attribute is encountered while walking down the DOM tree, Templado checks whether the current view model implements a vocab() method. If not, the attribute is ignored. Otherwise, Templado will call the method, passing in the value of the vocab attribute. The return value is expected to be a string that Templado then can compare against the specified vocab - as in, the value of the vocab attribute. If they match, Templado considers the view model to be responsible for this vocabulary and will try to render it. Again, this is probably best understood with an example. A simple HTML fragment, that has a vocab attribute set could look like this: <p vocab=\"https://example.com#book\">Hello world</p> To specify a view model that is considered responsible for this vocabulary, various options exist. All the following examples lead to the same result. class MyRootModel { public function vocab(string $requested): string { return $requested; } } class MyRootModel { public function vocab(): string { return \"https://example.com#book\"; } } class MyRootModel { public string $vocab = \"https://example.com#book\"; } If you want to not have the view model be applied, you have to return a none-matching string. So if the requested vocabulary would for instance be \"https://schema.org\", the last two examples above would already qualify as not being responsible. The first example simply returns the input string and thus would always be considered responsible. The implementation could just as well be removed as it's technically identical to not having a vocab() method at all - but some prefer to make it explicit.","title":"vocab"},{"location":"features/view-model/#property","text":"","title":"property"},{"location":"features/view-model/#supported-return-types","text":"","title":"Supported Return Types"},{"location":"features/view-model/#string","text":"","title":"String"},{"location":"features/view-model/#signalignore-or-true","text":"","title":"Signal::ignore (or true)"},{"location":"features/view-model/#signalremove-or-false","text":"","title":"Signal::remove (or false)"},{"location":"features/view-model/#iterables-eg-arrays-or-iterator","text":"","title":"Iterables (e.g. Arrays or Iterator)"},{"location":"features/view-model/#view-model-objects","text":"","title":"View Model Objects"},{"location":"features/view-model/#operating-on-html-attributes","text":"Apart from setting the text content of an element, Templado supports changing the value of or entirely removing existing attributes. Templado will not add new attributes. Note To not break Templado's flow of operation, the supported RDFa attributes are protected and can not be changed or removed using a view model. If you prefer to have RDFa attributes removed at the end of processing, this can be achieved by using the Serliazer .","title":"Operating on HTML Attributes"},{"location":"features/view-model/#supported-types-for-attribute-rendering","text":"","title":"Supported Types for Attribute Rendering"},{"location":"features/view-model/#string_1","text":"","title":"# String"},{"location":"features/view-model/#signalignore-or-true_1","text":"","title":"# Signal::ignore (or true)"},{"location":"features/view-model/#signalremove-or-false_1","text":"","title":"# Signal::remove (or false)"},{"location":"features/view-model/#resource","text":"","title":"resource"},{"location":"features/view-model/#prefix","text":"","title":"prefix"},{"location":"features/view-model/#typeof","text":"","title":"typeof"},{"location":"migrate/templado4/","text":"","title":"Templado 4.x"}]}