<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Arne Blankerts <arne@blankerts.de> and contributors" /><link rel="canonical" href="https://docs.templado.io/start/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>First Steps - Templado Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link href="../highlight/github.min.css" rel="stylesheet" />
        <link href="../css/templado.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "First Steps";
        var mkdocs_page_input_path = "start.md";
        var mkdocs_page_url = "/start/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]--> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="..">
          <img src="../img/templado-logo.svg" class="logo" alt="Logo"/>
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Getting Started</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../install/">Installation</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">First Steps</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#associate-a-template-with-a-view-model">Associate A Template With A View Model</a>
    </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Concepts</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../concept/viewmodel/">View Models</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../concept/transformation/">Transformation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../concept/forms/">Form Handling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../concept/filter/">Filtering</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../concept/merge/">Merging</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Reference</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../use/document/">Documents</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../use/viewmodels/">View Models</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../use/transformations/">Transformations</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../use/filter/">Filters</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../use/serializer/">Serialization</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../use/merge/">Merging</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Templado Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
          <li>Getting Started &raquo;</li>
      <li class="breadcrumb-item active">First Steps</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/templado/documentation/blob/main/src/start.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="getting-started">Getting Started</h2>
<p>As with any templating engine, the goal is to pair a template with a data source. Templado uses View Models and XHTML
templates to accomplish this. So the first thing we need to do is introduce them to each other.</p>
<h3 id="associate-a-template-with-a-view-model">Associate A Template With A View Model</h3>
<p>Here is an example of code to pair a data model with a template:</p>
<pre><code class="language-php">try {
    $page = Templado\Engine\Templado::loadHtmlFile(
        new Templado\Engine\FileName(__DIR__ . '/html/viewmodel.xhtml')
    );

    $page-&gt;applyViewModel(new ViewModel());

    echo $page-&gt;asString() . &quot;\n&quot;;

} catch (Templado\Engine\TempladoException $e) {
    foreach($e-&gt;getErrorList() as $error) {
        echo (string)$error;
    }
}
</code></pre>
<p>Let's quickly parse this code.</p>
<p>First, we instantiate a Templado\Engine\Html object. To accomplish this we use the static method
Templado\Engine\Templado::loadHtmlFile. <em>Notice that we create a new Templado FileName object to pass into the method.</em></p>
<p>Once loaded, we call the "applyViewModel" method, and pass in our View Model.</p>
<p>This Object does not have to be called "ViewModel". The name is arbitrary. It is called that here for clarity.</p>
<p>Now that the pairing is complete, you can simply call the "asString" method to output the rendered file.</p>
<p>Finally, we wrap it in a try/catch, and that's it. With this you are ready to begin templating.</p>
<h2 id="basic-usage">Basic Usage</h2>
<p>One of the great features of Templado is that it relies entirely on HTML markup, with no need for you to learn any
new language or syntax. Templado has the ability to modify all aspects of your html template. Let's start with basic
markup elements.</p>
<h3 id="elements-and-attributes">Elements and Attributes</h3>
<p>Templado makes use of four standard attributes in your markup elements ("property", "resource", "prefix", and "typeOf").
If you are not familiar, these attributes are all standard recommendations from the <a href="https://en.wikipedia.org/wiki/RDFa">RFDa</a>
and are a means of incorporating rich metadata into documents. We will cover each of these, but let's start with the
"property" attribute since this is likely the most common usage.</p>
<p>Let's say that you have a header tag in your template.</p>
<pre><code class="language-html">&lt;h1&gt;Some Title&lt;/h1&gt;
</code></pre>
<p>Templado looks at each element to see if it has a "property" attribute. If it finds one, it looks for a method in
your View Model who's name matches the attribute's value.</p>
<pre><code class="language-html">&lt;h1 property=&quot;headline&quot;&gt;Some Title&lt;/h1&gt;
</code></pre>
<p>In this example, Templado would access the View Model for this template, and look for a method named "headline".</p>
<pre><code class="language-php">class ViewModel {
    public function headline() {
        return &quot;The Actual Title&quot;;
    }
}
</code></pre>
<p>Continuing with this example, the method is returning a string, and so Templado would use the returned string as the
text value for the header:</p>
<pre><code class="language-html">&lt;h1 property=&quot;headline&quot;&gt;The Actual Title&lt;/h1&gt;
</code></pre>
<p>It's that simple, and this will work for any HTML element. However it gets much better. Instead of returning a string,
your View Model method can return an Object representing the HTML element. This Object can have methods that represent
any of the attributes of your HTML element ...</p>
<pre><code class="language-html">&lt;h1 property=&quot;headline&quot; title=&quot;A Title&quot; class=&quot;a-class&quot;&gt;Some Title&lt;/h1&gt;
</code></pre>
<p>In this example our header now has two attributes - "title" and "class". So we can create a class that looks like this:</p>
<pre><code class="language-php">class Headline {
    public function title() {
        return &quot;Awsome Title&quot;;
    }

    public function class() {
        return &quot;cool-class&quot;;
    }

    public function asString() {
        return &quot;The Actual Title&quot;;
    }
}
</code></pre>
<p>And then return a new instance of our Headline object from the View Model method.</p>
<pre><code class="language-php">class ViewModel {
    public function headline() {
        return new Headline();
    }
}
</code></pre>
<p>When an Object is returned Templado will look for methods in the Object that match the names of the attributes of the
element in the template.</p>
<p><strong>Note that Templado looks for a method specifically called "asString" for the text value of the element.</strong></p>
<p>Now our header will render like this:</p>
<pre><code class="language-html">&lt;h1 property=&quot;headline&quot; title=&quot;Awsome Title&quot; class=&quot;cool-class&quot;&gt;The Actual Title&lt;/h1&gt;
</code></pre>
<p>In addition, if for any reason you have an attribute in your template, but you want to remove it for this data model,
you can simply return false from the method. So if our Headline object returned false for the class method, our rendered
header would then look like this:</p>
<pre><code class="language-html">&lt;h1 property=&quot;headline&quot; title=&quot;Awsome Title&quot;&gt;The Actual Title&lt;/h1&gt;
</code></pre>
<p>Pretty cool, but there is one more feature to discuss about elements and attributes.</p>
<p>Templado captures the values of elements and attributes from the template. And if a method in your Object takes a
parameter, then the value is passed in.</p>
<p>So let's say your Object looks like this now:</p>
<pre><code class="language-php">class Headline {
    public function title() {
        return &quot;Awsome Title&quot;;
    }

    public function class($original) {
        return $original . &quot; cool-class&quot;;
    }

    public function asString() {
        return &quot;The Actual Title&quot;;
    }
}
</code></pre>
<p>You see that we have added a parameter called $original (<em>the parameter name is up to you</em>), and we then concatenate the
the class from the template with our new class, and return that.</p>
<p>So now our header would render like this:</p>
<pre><code class="language-html">&lt;h1 property=&quot;headline&quot; title=&quot;Awsome Title&quot; class=&quot;a-class cool-class&quot;&gt;The Actual Title&lt;/h1&gt;
</code></pre>
<p>Again this will work with all elements and attributes.</p>
<p>The fact is that you could stop reading right here, and with only these few features accomplish many of your templating
goals! You can create an Object to represent any HTML element and all of its attributes. This is cool, but keep reading.
There is much more.</p>
<h3 id="dynamic-lists">Dynamic Lists</h3>
<p>One special case/feature of Templado is that a View Model method can return an array. This allows for multiples of an
element to be rendered consecutively with different data for each. The most obvious usage for this is with lists.</p>
<p>Let's say that you need an unordered list of items displayed. When you are creating your template, you have no idea
of the number of items that will need to be shown. This is not an issue.</p>
<p>In your template you can create the unordered list with a single list item element, and give it a "property" attribute:</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li property=&quot;items&quot;&gt;Item 1&lt;/li&gt;
&lt;/ul&gt; 
</code></pre>
<p>Then in your View Model, the "items" method can return an array of list items:</p>
<pre><code class="language-php">class ViewModel {
    public function items() {
        return [
            &quot;Item 1&quot;, 
            &quot;Item 2&quot;,
            &quot;Item 3&quot; 
        ];
    }
}
</code></pre>
<p>In this case the rendered elements would like this:</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li property=&quot;items&quot;&gt;Item 1&lt;/li&gt;
    &lt;li property=&quot;items&quot;&gt;Item 2&lt;/li&gt;
    &lt;li property=&quot;items&quot;&gt;Item 3&lt;/li&gt;
&lt;/ul&gt; 
</code></pre>
<p>Notice that in this example we returned an array of strings, so Templado used the strings as the text for each list item.
Just as with our previous element examples, you can also return an array of Objects. These Objects will represent each
list item element ... just as before.</p>
<p>In the template:</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li property=&quot;items&quot; class=&quot;odd&quot;&gt;Item 1&lt;/li&gt;
&lt;/ul&gt; 
</code></pre>
<p>In the View Model:</p>
<pre><code class="language-php">class ViewModel {
    public function items() {
        return [
            new Item(&quot;odd&quot;, &quot;Item 1&quot;), 
            new Item(&quot;even&quot;, &quot;Item 2&quot;),
            new Item(&quot;odd&quot;, &quot;Item 3&quot;)
        ];
    }
}
</code></pre>
<p>And of course you would need an Item class:</p>
<pre><code class="language-php">class Item {
    /**
     * @var string
     */
    private $class;

    /**
     * @var string
     */
    private $value;

    public function __construct($class, $value) {
        $this-&gt;$class = $class;
        $this-&gt;value = $value;
    }

    public function class() {
        return $this-&gt;class;
    }

    public function asString() {
        return $this-&gt;value;
    }
}
</code></pre>
<p>And now the rendered elements would like this:</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li property=&quot;items&quot; class=&quot;odd&quot;&gt;Item 1&lt;/li&gt;
    &lt;li property=&quot;items&quot; class=&quot;even&quot;&gt;Item 2&lt;/li&gt;
    &lt;li property=&quot;items&quot; class=&quot;odd&quot;&gt;Item 3&lt;/li&gt;
&lt;/ul&gt; 
</code></pre>
<p>One of the nicest features about Templado is that your template files can be rendered in a browser without the
associated data. You can see how your template looks without concern over what data will be passed to it.</p>
<p>Given this, there may be times that you want your template to look more fleshed out. For example, even though you don't
know exactly how many items will be displayed, you are sure that in most cases it will be several. Let's say you expect
an average of about 5 items. The final page will look very different than your raw template if the template only has one
item as a placeholder.</p>
<p>This is not a problem. With Templado, you can add as many elements as you deem necessary in the template.</p>
<p>So your template can look like this:</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li property=&quot;items&quot; class=&quot;odd&quot;&gt;Item 1&lt;/li&gt;
    &lt;li property=&quot;items&quot; class=&quot;even&quot;&gt;Item 2&lt;/li&gt;
    &lt;li property=&quot;items&quot; class=&quot;odd&quot;&gt;Item 3&lt;/li&gt;
    &lt;li property=&quot;items&quot; class=&quot;even&quot;&gt;Item 4&lt;/li&gt;
    &lt;li property=&quot;items&quot; class=&quot;odd&quot;&gt;Item 5&lt;/li&gt;
&lt;/ul&gt; 
</code></pre>
<p>But your rendered elements will still look like this if we use the View Model from before:</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li property=&quot;items&quot; class=&quot;odd&quot;&gt;Item 1&lt;/li&gt;
    &lt;li property=&quot;items&quot; class=&quot;even&quot;&gt;Item 2&lt;/li&gt;
    &lt;li property=&quot;items&quot; class=&quot;odd&quot;&gt;Item 3&lt;/li&gt;
&lt;/ul&gt; 
</code></pre>
<p>If your View Model method returns ten items, then the rendered list will have ten items.</p>
<p>The bottom line is that you can design your templates to look realistic, and still know that they will render dynamically.
This is a nice advantage over other templating engines.</p>
<h3 id="nesting">Nesting</h3>
<p>It should be relatively obvious at this point, but to be explicit, just as HTML can have many levels of nesting, so can
your View Models.</p>
<p>Take this template as an example:</p>
<pre><code class="language-html">&lt;div property=&quot;user&quot;&gt;
    &lt;p&gt;Name: &lt;span property=&quot;name&quot;&gt;Original Name&lt;/span&gt;&lt;/p&gt;
    &lt;div&gt;
        &lt;span&gt;EMail:&lt;/span&gt;
        &lt;ul&gt;
            &lt;li property=&quot;emailLinks&quot;&gt;
                &lt;a property=&quot;email&quot; href=&quot;mailto:original@domain.tld&quot; class=&quot;current&quot;&gt;original@domain.tld&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Here the top level element has a property called "user". Within the scope of the "user", we have two properties - "name"
and "emailLinks". And within the emailLinks scope we have a property called "email". So from a property point of view we
have 3 levels of nesting.</p>
<p>So our View Model will follow this schema as follows:</p>
<pre><code class="language-php">class ViewModel {
    public function user() {
        return new User();
    }
}
</code></pre>
<p>And the User:</p>
<pre><code class="language-php">class User {

    public function name() {
        return 'Willi Wichtig';
    }

    public function emailLinks() {
        return [
            new EMailLink(
                new Email('willi@wichtig.de')
            ),
            new EMailLink(
                new Email('second@secondis.de')
            )
        ];
    }

}
</code></pre>
<p>When the scope changes in the template, it follows in the Models. So now Templado is looking at the User Model for the
"name" and "emailLinks" methods. We see that the "emailLinks" method is returning an array of EmailLink objects.
So each EmailLink is rendered in the list, and then Templado looks to each of the EmailLink objects to resolve the
email property. And our EmailLink object looks like this:</p>
<pre><code class="language-php">class EMailLink {

    /** @var  Email */
    private $email;

    /**
     * @param Email $email
     */
    public function __construct(Email $email) {
        $this-&gt;email = $email;
    }

    public function email() {
        return $this-&gt;email;
    }
}
</code></pre>
<p>Finally, our Email object corresponds to an anchor element in our template. So Templado is looking for methods which
match the attributes of the anchor:</p>
<pre><code class="language-php">class Email {

    /** 
     * @var string 
     */
    private $addr;

    public function __construct(string $addr) {
        $this-&gt;addr = $addr;
    }

    public function asString() {
        return $this-&gt;addr;
    }

    public function href() {
        return 'mailto:' . $this-&gt;asString();
    }

    public function class() {
        return false;
    }
}
</code></pre>
<p>Notice that we returned false for the class property, which removes it from the rendered output. We could have, as another
example, set a flag in our Email object to signify the "current" or "preferred" email, and then output that
dynamically. The options become almost limitless for you as you create more complex templates. The nesting and dynamic
complexity is up to you and the requirements of your project.</p>
<h3 id="the-other-special-attributes-prefix-resource-and-typeof">The Other Special Attributes - Prefix, Resource and TypeOf</h3>
<p>As we mentioned in the beginning, Templado makes use of four RFDa recommended attributes. We covered the "property"
attribute so what about these others. As should be clear, the "property" attribute gives Templado a context (scope)
within which to work. However there may be times (for various reasons) that the context needs to change. Both "prefix"
and "resource" provide a means to do that. They are all somewhat similar in that way, yet each one has its own
specific usage. The "typeof" attribute is a little different, so we will save that one for last. Let's go over each of
these attributes one by one.</p>
<h4 id="prefix">Prefix</h4>
<p>Let's start with the "prefix" attribute. It is simply a way to alias (or namespace) your properties. Let's say that you
have a property called "user" that you want to reference multiple times. You can use the "prefix" attribute in place of
the "property" attribute to accomplish this:</p>
<pre><code class="language-html">&lt;div prefix=&quot;u: user&quot;&gt;
    &lt;p&gt;Name: &lt;span property=&quot;u:name&quot;&gt;Original Name&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;span&gt;EMail:&lt;/span&gt;
    &lt;ul&gt;
        &lt;li property=&quot;u:emailLinks&quot;&gt;
            &lt;a property=&quot;email&quot; href=&quot;mailto:original@domain.tld&quot; class=&quot;current&quot;&gt;original@domain.tld&lt;/a&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>In our prefix attribute we used the letter "u" (<em>short for user, obviously</em>) followed by a colon and a space, then
the property that we want to reference (<em>in this case "user"</em>).</p>
<p>Now, since we have created an alias for the user property, notice that we must use the colon notation to reference its
methods/properties. (<em>"u:" followed by the method name</em>)</p>
<p>But now we can reference it from anywhere else in our template. Notice that the "u:emailLinks" property is used
<strong>outside</strong> of the user element. This can be quite useful if you have the need to reference the user property several
times (or in several places) within your template.</p>
<h4 id="resource">Resource</h4>
<p>Let's move on to the "resource" attribute. It is similar to prefix in that it is also used in place of the
property attribute, and it is also a way that we can reference a property's methods elsewhere in our template. The
important difference is that "resource" tells Templado to look back to our main (<em>top level</em>) View Model. This is quite
useful in situations where a property is nested within the scope of another property in your template.</p>
<p>Let's say that you want to display "user" information in two (<em>or more</em>) different sections in your template. And each
of these instances of user in nested within the scope of another property. Rather than duplicating the user methods
within each of the parent Property Models, your can define the user method within the top level View Model, and then use
the resource attribute to reference it there.</p>
<pre><code class="language-html">&lt;div property=&quot;sectionOne&quot;&gt;
    &lt;h2 property=&quot;sectionTitle&quot;&gt;Section Title&lt;/h2&gt;
    &lt;div resource=&quot;user&quot;&gt;
        &lt;p&gt;Name: &lt;span property=&quot;name&quot;&gt;Original Name&lt;/span&gt;&lt;/p&gt;
        &lt;div&gt;
            &lt;span&gt;EMail:&lt;/span&gt;
            &lt;ul&gt;
                &lt;li property=&quot;emailLinks&quot;&gt;
                    &lt;a property=&quot;email&quot; href=&quot;mailto:original@domain.tld&quot; class=&quot;current&quot;&gt;original@domain.tld&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div property=&quot;sectionTwo&quot;&gt;
    &lt;h2 property=&quot;sectionTitle&quot;&gt;Section Title&lt;/h2&gt;
    &lt;div resource=&quot;user&quot;&gt;
        &lt;p&gt;Name: &lt;span property=&quot;name&quot;&gt;Original Name&lt;/span&gt;&lt;/p&gt;
        &lt;div&gt;
            &lt;span&gt;EMail:&lt;/span&gt;
            &lt;ul&gt;
                &lt;li property=&quot;emailLinks&quot;&gt;
                    &lt;a property=&quot;email&quot; href=&quot;mailto:original@domain.tld&quot; class=&quot;current&quot;&gt;original@domain.tld&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>In this case user is nested with the scope of the sections (one and two), but because we used resource instead of
property, Templado will look to our original View Model, rather than the Section Models.</p>
<pre><code class="language-php">class ViewModel {
    public function sectionOne() {
        return new SectionOne();
    }

    public function sectionTwo() {
        return new SectionTwo;
    }

    public function user() {
        return new User();
    }   
} 
</code></pre>
<p>Each of the Section Models would define their own "name" method in our example, but there is no need to add the user
methods to them. Templado already knows where to find it!</p>
<h4 id="typeof">TypeOf</h4>
<p>Finally, let's discuss the "typeof" attribute. This one works a bit differently than the others. Rather than replacing
the "property" attribute, "typeof" is used in conjunction with it. Also, rather than changing the context of the View Model
being used, the "typeof" attribute gives you a way to conditionally change your template. It allows you to create
multiple ways that an element could be displayed, and then select which version to use at rendering time.</p>
<p>Let's go back to our User example. Say you have three different kinds of Users. A standard User, a Commenter, and a
Moderator (to use a very contrived example). When you display a standard User, you want it to look like it did in our
previous examples - with a name and email addresses. However when you display a Moderator, you want to show that it is a
Moderator, and you do not want to display the Moderator's email address(es). And when it is a commenter, you only want to
display the name, and this User's rating - which a number rating from 1 to 5.</p>
<p>In this case, you can create a template that contains all three display versions. And identify each using the "typeof"
attribute.</p>
<pre><code class="language-html">... 

&lt;div property=&quot;user&quot; typeof=&quot;standard&quot;&gt;
    &lt;p&gt;Name: &lt;span property=&quot;name&quot;&gt;Original Name&lt;/span&gt;&lt;/p&gt;
    &lt;div&gt;
        &lt;span&gt;EMail:&lt;/span&gt;
        &lt;ul&gt;
            &lt;li property=&quot;emailLinks&quot;&gt;&lt;a property=&quot;email&quot; href=&quot;mailto:original@domain.tld&quot; class=&quot;current&quot;&gt;original@domain.tld&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div property=&quot;user&quot; typeof=&quot;moderator&quot;&gt;
    &lt;p&gt;Moderator: &lt;span property=&quot;name&quot;&gt;Original Name&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div property=&quot;user&quot; typeof=&quot;commentor&quot;&gt;
    &lt;p&gt;
        Commenter: &lt;span property=&quot;name&quot;&gt;Original Name&lt;/span&gt; 
        Rating: &lt;span property=&quot;rating&quot;&gt;5&lt;/span&gt;
    &lt;/p&gt;
&lt;/div&gt;

... 

</code></pre>
<p>Notice that each of the three main divs has a "property" of "user". But each has a different "typeof".</p>
<p>When Templado finds a "typeof" attribute, it look to the current View Model for a method specifically called "typeof".
This "typeof" method should return a string that matches one of template occurrences.</p>
<p>So now if our User Model is modified to look like this:</p>
<pre><code class="language-php">class User {

    public function name() {
        return 'Willi Wichtig';
    }

    public function emailLinks() {
        return [
            new EMailLink(
                new Email('willi@wichtig.de')
            ),
            new EMailLink(
                new Email('second@secondis.de')
            )
        ];
    }

    public function rating()
    {
        return '3';
    }

    public function typeof()
    {
        return 'standard';
    }
}
</code></pre>
<p>Templado would first look for the "typeof" method in the current View Model. It sees that, in this case, "standard" is
returned. So it looks back to our template, and ONLY renders the User element that has been identified as "standard".
The other two are removed.</p>
<pre><code class="language-html">&lt;div property=&quot;user&quot; typeof=&quot;standard&quot;&gt;
    &lt;p&gt;Name: &lt;span property=&quot;name&quot;&gt;Willi Wichtig&lt;/span&gt;&lt;/p&gt;
    &lt;div&gt;
        &lt;span&gt;EMail:&lt;/span&gt;
        &lt;ul&gt;
            &lt;li property=&quot;emailLinks&quot;&gt;&lt;a property=&quot;email&quot; href=&quot;mailto:willi@wichtig.de&quot; class=&quot;current&quot;&gt;willi@wichtig.de&lt;/a&gt;&lt;/li&gt;
            &lt;li property=&quot;emailLinks&quot;&gt;&lt;a property=&quot;email&quot; href=&quot;mailto:second@secondis.de&quot; class=&quot;current&quot;&gt;second@secondis.de&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>If we go back to our User Model and simply change the "typeof" method to return "moderator", then our output would look
like this:</p>
<pre><code class="language-html">&lt;div property=&quot;user&quot; typeof=&quot;moderator&quot;&gt;
    &lt;p&gt;Moderator: &lt;span property=&quot;name&quot;&gt;Willi Wichtig&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>And if we changed the "typeof" method to return "commenter":</p>
<pre><code class="language-html">&lt;div property=&quot;user&quot; typeof=&quot;commentor&quot;&gt;
    &lt;p&gt;
        Commenter: &lt;span property=&quot;name&quot;&gt;Willi Wichtig&lt;/span&gt; 
        Rating: &lt;span property=&quot;rating&quot;&gt;3&lt;/span&gt;
    &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>So you see, even from this silly example, that we can easily configure any number of template <em>views</em> for a given View Model,
and then switch views by simply updating the return value for one method. This gives you incredible control over your
templates, and so many options for how to configure things.</p>
<h3 id="forms">Forms</h3>
<p>Forms are a bit of a special case in templating. Though there may be times that you do want to dynamically set field
attributes (<em>which can be handled with the methods discussed above</em>), one important need is that of populating the form
fields with the supplied data. And though technically, with some forethought, you could handle the particulars of each
field with the methods discussed above, Templado simplifies this task for you through the Templado\Engine\FormData Object.</p>
<p>Instantiating a FormData Object is easy. The constructor takes two parameters. The first is an identifier for the form,
which can be either the form "name" or "id" attribute. The second is simply an array where the keys are the field names,
and the values are, of course, the field values (<em>coincidentally, just as the post data of the form would look</em> ;).</p>
<p>So if you have a form in your template that looks like this:</p>
<pre><code class="language-html">&lt;form id=&quot;user-form&quot;&gt;
    &lt;p&gt;&lt;label for=&quot;name&quot;&gt;Name: &lt;/label&gt;&lt;input id=&quot;name&quot; name=&quot;name&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label for=&quot;email&quot;&gt;Email: &lt;/label&gt;&lt;input id=&quot;email&quot; name=&quot;email&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label for=&quot;address&quot;&gt;Phone: &lt;/label&gt;&lt;input id=&quot;phone&quot; name=&quot;phone&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;
        &lt;label for=&quot;gender&quot;&gt;Gender: &lt;/label&gt;
        &lt;select id=&quot;gender&quot; name=&quot;gender&quot;&gt;
            &lt;option value=&quot;female&quot;&gt;Female&lt;/option&gt;
            &lt;option value=&quot;male&quot;&gt;Male&lt;/option&gt;
        &lt;/select&gt;
    &lt;/p&gt;
    &lt;p&gt;&lt;label for=&quot;description&quot;&gt;Description: &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;textarea id=&quot;description&quot; name=&quot;description&quot; rows=&quot;3&quot; cols=&quot;32&quot;&gt;&lt;/textarea&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label for=&quot;available&quot;&gt;Available: &lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;available&quot; name=&quot;available&quot; value=&quot;yes&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;Handed::
        &lt;label for=&quot;handed-left&quot;&gt;Left: &lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;handed-left&quot; name=&quot;handed&quot; value=&quot;left&quot; /&gt;
        &lt;label for=&quot;handed-right&quot;&gt;Right: &lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;handed-right&quot; name=&quot;handed&quot; value=&quot;right&quot; /&gt;
    &lt;/p&gt;
    &lt;button&gt;submit&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p>And you have form data/values that looks like this:</p>
<pre><code class="language-php">$formValues = [
    'name' =&gt; 'Boo Radley',
    'email' =&gt; 'boo@templado.com',
    'phone' =&gt; '555-1212',
    'gender' =&gt; 'male',
    'description' =&gt; 'Reserved, but thoughtful and kind fellow',
    'available' =&gt; 'yes',
    'handed' =&gt; 'right'
];
</code></pre>
<p>You simply instantiate a FormData Object like this:</p>
<pre><code class="language-php">$formData = new Templado\Engine\FormData('user-form', $formValues);
</code></pre>
<p>And going back to our original template and data pairing code, apply it using the "applyFormData" method like this:</p>
<pre><code class="language-php">try {
    $page = Templado::loadHtmlFile(
        new FileName(__DIR__ . '/html/form.xhtml')
    );

    $page-&gt;applyFormData($formData);

    echo $page-&gt;asString();

} catch (TempladoException $e) {
    foreach($e-&gt;getErrorList() as $error) {
        echo (string)$error;
    }
}
</code></pre>
<p>And now your rendered form will have each field properly populated. <em>It should be noted that the FormData Object can also
handle multi-dimensional form data arrays</em>.</p>
<p><strong>It should also be noted that password fields and file type fields are excluded for security reasons.</strong></p>
<p>While we are on the subject of forms, there is one more Templado feature that applies here. You are hopefully familiar
with Cross-Site Request Forgery (<strong>CSRF</strong>). A full explanation of this security issue is well beyond the scope of this
documentation. You can find more information about it <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">here</a></p>
<p>A suggested method to protect against CSRF is the Synchronizer Token Pattern (<strong>STP</strong>), which involves adding a unique
(<em>and unpredictable</em>) token to a hidden field when posting your form. Then of course, validating that token when processing
of the form.</p>
<p>Templado lets you dynamically add the hidden field to your form using the Templado\Engine\CSRFProtector Object. To
instantiate this Object, you simply pass in a name for your (<em>soon to be</em>) field, and a token. <strong>It is important to note
that how you generate and track your token is up to you</strong>.</p>
<p>But once you have a token, you can create the CSRFProtector like this:</p>
<pre><code class="language-php">$csrfProtector = new Templado\Engine\CSRFProtector('csrf-token', 'somelongtokenstring');
</code></pre>
<p>In this example we are naming our future hidden field 'csrf-token' (<em>the name is up to you</em>). <em>Obviously, the token
itself would be different.</em></p>
<p>And we can add it to our form using the "applyCSRFProtection" method like this (<em>following the above form example</em>):</p>
<pre><code class="language-php">try {
    $page = Templado::loadHtmlFile(
        new FileName(__DIR__ . '/html/form.xhtml')
    );

    $page-&gt;applyCSRFProtection($csrfProtector);

    $page-&gt;applyFormData($formData);

    echo $page-&gt;asString();

} catch (TempladoException $e) {
    foreach($e-&gt;getErrorList() as $error) {
        echo (string)$error;
    }
}
</code></pre>
<p>And now a new <strong>hidden</strong> input field will be rendered in your form with the name 'csrf-token', and a value of the token
you passed in. Now, with some validation on the backend, your form is safer.</p>
<p>**Note: If a CSRF hidden field (with that name) already exists, rather than creating a new field, the existing field will
be used. Its value will be updated.</p>
<hr />
<p>So at this point we have pretty much covered all that you need to effectively create and manipulate basic templates. It
is simple to use, clean and leaves you with templates that can be displayed on their own as representational pages.</p>
<p>In our, final section we will cover a few slightly more abstract features - Snippets, Transformations, and Filters.
These options give you full control over your final output.</p>
<h3 id="snippets">Snippets</h3>
<p>Some templates, depending on your project and the requirements, can get a little complex. Perhaps, in these situations
it would be nice to break the template down into smaller parts. Or maybe you have reusable static code blocks, and/or
module elements that you don't want to keep duplicating. This is where Snippets come in. They allow you to write smaller,
more manageable pieces of code, and then pull them all together on the fly.</p>
<p>Let's start as simply as possible, and you will immediately see how the possibilities of use are almost unlimited.</p>
<p>Say we have the following template code:</p>
<pre><code class="language-html">&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;Basic Snippet&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;header&quot; /&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Now you want to add a page title to the existing header div. You do this by first creating a \DOMNode. There are various
ways to accomplish this. One straight forward way is with \DOMDocument::createElement:</p>
<pre><code class="language-html">$codeBlock = new \DOMDocument();
$header = $codeBlock-&gt;createElement('h1', 'This Is A Simple Snippet Example');
</code></pre>
<p>Now that we have a \DOMNode, we can easily create a Templado Snippet.</p>
<pre><code>$snippet = new \Templado\Engine\SimpleSnippet('header', $element);
</code></pre>
<p>Notice that the first parameter is the target id (from our template). The second parameter is of course the element to be added.</p>
<p>The method to apply Snippets to a Templado Html object expects a \Templado\Engine\SnippetListCollection. Even though we
are adding only one Snippet in this example, we will still need to instantiate the Collection, and add our Snippet:</p>
<pre><code>$snippetListCollection = new SnippetListCollection();
...
$snippetListCollection-&gt;addSnippet($snippet);
</code></pre>
<p>If we had multiple Snippets to apply, we could simply add them to the Collection. But for this example we can just go ahead
and apply this one using the \Templado\Engine\Html::applySnippets method. We put it all together like so:</p>
<pre><code class="language-php">try {
    $page = Templado::loadHtmlFile(
        new FileName(__DIR__ . '/html/basic.xhtml')
    );

    $snippetListCollection = new SnippetListCollection();

    $codeBlock = new \DOMDocument();
    $element = $codeBlock-&gt;createElement('h1', 'This Is A Simple Snippet Example');
    $snippet = new SimpleSnippet('header', $element);

    $snippetListCollection-&gt;addSnippet($snippet);

    $page-&gt;applySnippets($snippetListCollection);

    echo $page-&gt;asString();

} catch (TempladoException $e) {
    foreach($e-&gt;getErrorList() as $error) {
        echo (string)$error;
    }
}
</code></pre>
<p>Our Snippet gets applied, and the final rendered page in our example looks like this:</p>
<pre><code class="language-html">&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;Basic Snippet&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;header&quot;&gt;
            &lt;h1&gt;This Is A Simple Snippet Example&lt;/h1&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Of course, in most cases you are are not going to want to add single simple elements one by one. You can easily create more
complex Snippets by loading a partial HTML string into your DOMDocument, and then extracting the root element that you want:</p>
<pre><code>$codeSample = new \DOMDocument();

$htmlString = '&lt;div id=&quot;header&quot;&gt;&lt;h1&gt;This is a more &lt;span class=&quot;red&quot;&gt;complex header&lt;/span&gt;&lt;p&gt;Click &lt;a href=&quot;some-link&quot;&gt;HERE&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;';

$codeSample-&gt;loadHTML($htmlString);

$element = $codeSample-&gt;getElementById('header');
</code></pre>
<p>As long as your HTML string is valid, this method will work! The rest of the process would be the same. Simply create a
SimpleSnippet from our (more complex) DOMElement, add it to a SnippetListCollection, and apply it to the Page. And now our
rendered page looks like this:</p>
<pre><code class="language-html">&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;Basic Snippet&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;header&quot;&gt;
            &lt;h1&gt;This is a more &lt;span class=&quot;red&quot;&gt;complex header&lt;/span&gt;
            &lt;p&gt;Click &lt;a href=&quot;some-link&quot;&gt;HERE&lt;/a&gt;&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>In this example we used a single element (with children) as our Snippet. And since the id of the Snippet element
matched the id of the template element, the template element was replaced.</p>
<p><strong>Note:</strong> If Templado does not find an element matching our target id, our Snippet is ignored.</p>
<p>If instead of replacing the template element, you want to append multiple children to it. You could, of course, create
each of the child elements as individual Snippets and add them all to the Collection, but this would be quite tedious.
If you wanted to group them as one Snippet there would be an issue because they would not a have common root element.
Your partial code would be invalid. For this case, we can use \Templado\Engine\TempladoSnippet.</p>
<p>We can take a partial HTML string, and simply wrap it in a Templado namespace.</p>
<p>So this string:</p>
<pre><code>$partialHtmlString = '&lt;h1&gt;This is a more &lt;span class=&quot;red&quot;&gt;complex header&lt;/span&gt;&lt;p&gt;Click &lt;a href=&quot;some-link&quot;&gt;HERE&lt;/a&gt;&lt;/p&gt;';
</code></pre>
<p>Becomes:</p>
<pre><code>$partialHtmlString = 
        '&lt;page:snippet xmlns:page=&quot;https://templado.io/snippets/1.0&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
            &lt;h1&gt;This is a more &lt;span class=&quot;red&quot;&gt;complex header&lt;/span&gt;&lt;p&gt;Click &lt;a href=&quot;some-link&quot;&gt;HERE&lt;/a&gt;&lt;/p&gt;
        &lt;/page:snippet&gt;';
</code></pre>
<p>Then we load our (now valid) XML into our DOMDocument.</p>
<pre><code>$codeSample = new \DOMDocument();
$codeSample-&gt;loadXML($partialHtmlString);

$snippet = new TempladoSnippet('header', $codeSample);
</code></pre>
<p>And again, the rest of the process is the same. We add it to a SnippetListCollection, and apply it to our page.</p>
<p>This is powerful, but let's get to the real point here. Snippets are way to combine, nest and modify blocks of code. But
notice that we are still working with the same base object - the Templado\Engine\Html object. And therefore, we can still
apply View Models to it.</p>
<p>Let's modify our example again. But this time let's create a more complex fragment:</p>
<pre><code class="language-php">... 

$xhtml = &lt;&lt;&lt;xhtml
    &lt;page:snippet xmlns:page=&quot;https://templado.io/snippets/1.0&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
        &lt;h1 id=&quot;main-title&quot;&gt;This Is A Simple Snippet Example And Then Some&lt;/h1&gt;
        &lt;div property=&quot;user&quot;&gt;
        &lt;p&gt;Name: &lt;span property=&quot;name&quot;&gt;Original Name&lt;/span&gt;&lt;/p&gt;
            &lt;span&gt;EMail:&lt;/span&gt;
            &lt;ul&gt;
                &lt;li property=&quot;emailLinks&quot;&gt;
                    &lt;a property=&quot;email&quot; href=&quot;mailto:original@domain.tld&quot; class=&quot;current&quot;&gt;original@domain.tld&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/page:snippet&gt;
xhtml;

$codeSample-&gt;loadXML($xhtml);

$snippet = new TempladoSnippet('header', $codeSample);

$snippetListCollection-&gt;addSnippet($snippet);

$page-&gt;applySnippets($snippetListCollection);
</code></pre>
<p>Once we have added our extended Snippet to our base template, but before we render it, we can apply our View Model:</p>
<pre><code class="language-php">$page-&gt;applyViewModel(new ViewModel());
</code></pre>
<p><strong>If you have not read the previous documentation on View Models and the property attribute, now would be a good to do so</strong>.
Otherwise, you understand that you would now get a fully rendered page.</p>
<p>Of course, it is also important to note that you can also change the order of operations here. You can quite easily load
partial code as a Templado\Engine\Html Object, apply a ViewModel to get a rendered partial code block. Then load that as
a Snippet, and apply it to a more complex page document.</p>
<p>This is quite useful if you want to combine static assets with dynamically created Snippets.</p>
<p>Additionally it should be pointed out that, since you can load the partial code from a file, it would be trivial to
create well organized, reusable code fragment files.</p>
<h4 id="snippetloader">SnippetLoader</h4>
<p>Which brings us to one final Snippet feature - Templado\Engine\SnippetLoader.</p>
<p>One way that you can create Snippets from a file, is with Templado\Engine\SnippetLoader. It basically has one public function
called "load", which takes in a Templado\Engine\FileName.</p>
<p>If all you want to do is add a simple TextNode, then you can just create a file with your text. Of course, you will still
want to wrap the text in a Templado namespace like in the above example. But other than that, you can simply instantiate
a SnippetLoader, load your file, and pass the Text Snippet along.</p>
<p>For more complex Snippets, you will want to add a DOCTYPE declaration to your file as well, so that Templado knows what
kind of document it is working with.</p>
<p>But again, all that is necessary is to call the load function, and you will get back a proper Snippet.</p>
<pre><code class="language-php">...

$snippetLoader = new SnippetLoader();

$snippet = $snippetLoader-&gt;load(new FileName(__DIR__ . 'code_fragment.xhtml'));

$snippetListCollection-&gt;addSnippet($snippet);

$page-&gt;applySnippets($snippetListCollection);

...

</code></pre>
<p>And there you have it. We could keep adding more and more complex examples, but it should be clear at this point just
how powerful this is. You can easily create more complex blocks of code that can be assembled in any number of ways.
These code fragments can be reused, and new Snippets can be added to them. As stated earlier, the ways this can be applied
are almost endless.</p>
<h3 id="transformations-and-filters">Transformations and Filters</h3>
<p>Occasionally, there may be times when you have the need to manipulate the final output beyond just applying data models.
Perhaps there is something that needs to be completely stripped out of the document, or changed based on the environment,
or for temporal reasons. The question of why you would need to change something is basically beside the point. There could
be any number of reasons. The question is how.</p>
<p>Templado gives you two options for handling these situations - Transformations and Filters. Let's start with Transformations.</p>
<p>Perhaps we decide that we do not want our final rendered markup to contain any of the RFDa attributes we used. These
attributes were for our templating purposes, and are superfluous once the rendering is complete. We can do this.
Templado gives you the option of writing and applying a Transformation.</p>
<h4 id="transformations">Transformations</h4>
<p>Templado\Engine\Transformation is an Interface with just two methods defined - "getSelector" and "apply".</p>
<p>The "getSelector" method is used to define which elements of the document you would like to affect. And the
"apply" method defines what you would actually like to do.</p>
<p>You could implement the Transformation Interface like this:</p>
<pre><code class="language-php">class StripRDFaAttributesTransformation implements Transformation {

    /** @var string[] */
    private $attributes = ['property', 'resource', 'prefix', 'typeof'];

    public function getSelector(): Selector {
        return new XPathSelector('//*[@' . implode(' or @', $this-&gt;attributes) . ']');
    }

    public function apply(DOMNode $context) {
        if (!$context instanceof \DOMElement) {
            return;
        }

        foreach($this-&gt;attributes as $attribute) {
            $context-&gt;removeAttribute($attribute);
        }
    }

}
</code></pre>
<p>The signatures of the methods are of course defined in the interface. The "getSelector" method must return a
Templado\Engine\Selector. Templado has two built in Classes that can help you with that. In this example we are using the
Templado\Engine\XPathSelector to define the Selector using XPath syntax. If you aren't familiar with this syntax you can
find a nice explanation <a href="https://www.w3schools.com/xml/xpath_syntax.asp">here</a></p>
<p>So in our example above, we instantiate a new XPathSelector using the syntax to select all elements that contain any of
the four RDFa attributes. As you can see, we have a private array containing the four attributes, and then use PHP's
"implode" method to create the selector string. And we return that.</p>
<p>Internally, the "apply" method is called with each element (<em>node</em>) that matches the selector. We make sure that what was
passed in is actually a DOMElement, and if so, we loop through the list of attributes and delete them.</p>
<p>It is easy enough to write a Transformation, but it is even easier to put it to use.</p>
<p>If we go back to the code where we are manipulating our templates, we can add one more line to apply our Transformation.</p>
<pre><code class="language-php">try {
    $page = Templado\Engine\Templado::loadHtmlFile(
        new Templado\Engine\FileName(__DIR__ . '/html/viewmodel.xhtml')
    );
    $page-&gt;applyViewModel(new ViewModel());

    $page-&gt;applyTransformation(new PropertyRemoverTransformation());

    echo $page-&gt;asString() . &quot;\n&quot;;

} catch (Templado\Engine\TempladoException $e) {
    foreach($e-&gt;getErrorList() as $error) {
        echo (string)$error;
    }
}
</code></pre>
<p>And that's it! In the final output, all elements containing the RFDa attributes would be gone.</p>
<p><strong>Note: if you think that's a pretty cool idea, you are in luck. The Templado\Engine\StripRDFaAttributesTransformation
class is part of the core Templado code.</strong> If you have other ideas for transforming your templates, you will need to write
them yourself, but this Transformation can be used out of the box.</p>
<p>I mentioned that there are two Classes in Templado that can be used to create a Selector. We used XPathSelector in this
example, but the other is Templado\Engine\CSSSelector. It extends the XPathSelector, and allows you to use CSS syntax
instead of XPath. Either way, Transformations are easy to use and a powerful way to modify your document.</p>
<p>And this brings us to the final way that Templado equips you to control your output. Transformations are a great to
manipulate DOM nodes, but that heavy lifting can come at an efficiency cost by having to traverse all those nodes. This
is where Filters come in. And this is the last stop in the process before your document is fully rendered.</p>
<h4 id="filters">Filters</h4>
<p>When you call the "asString" method on your Templado\Engine\Html object, your document is serialized. At this point, you
get one last chance to modify that string. To do this Templado features the Templado\Engine\Filter interface, which has
only one defined method called "apply". By creating an Object that implements Filter, you can ue the "apply" method to act
on the final serialized document just before it is output. Since it is a string, you can use regex, and/or any of PHP's
built in string modifying methods to tweak your document.</p>
<p>In all of our examples so far, we have simply called the "asString" method on our Html Object to create the final output.
It is important to note though, that this method takes in an optional Filter parameter. In fact, if you were to look under
the hood, you would see that Templado has two built in Filters that get run automagically inside the "asString"
method. One of these Filters truncates any left over empty HTML tags, and the other removes all XML Namespaces.</p>
<p>Let's take a look at the empty element Filter as a usage example:</p>
<pre><code class="language-php">class EmptyElementsFilter implements Filter {

    public function apply(string $content): string {
        $tagList = [
            'base', 'br', 'meta', 'link', 'img', 'input', 'button', 'hr', 'embed',
            'param', 'source', 'track', 'area', 'keygen',
        ];

        foreach($tagList as $tag) {
            $content = preg_replace(
                &quot;=&lt;{$tag}(.*[^&gt;]?)&gt;&lt;/{$tag}&gt;=U&quot;,
                &quot;&lt;{$tag}\$1 /&gt;&quot;,
                $content
            );
            if ($content === null) {
                throw new EmptyElementsFilterException(
                    'Error while processing regular expression',
                    preg_last_error()
                );
            }
        }

        return $content;
    }

}
</code></pre>
<p>And let's walk through this. As you can see, and as stated before, there is only one method to implement. This "apply"
method takes in the entire serialized document string, and returns it after any modifications.</p>
<p>So in this example, we see that an array of empty tag candidates is created. Then the code loops through each of those
tags, and performs a "preg_replace" on each one. It looks for tags that have both an open and close, but nothing inside.
If a match is found, the attributes of the original tag are copied to the short version of the tag, and the code continues.</p>
<p><strong>Note that since a replace can fail, this code throws an Exception if something goes wrong. Perhaps even more importantly
a custom Exception was created for this Class - an important best practice.</strong></p>
<p>Once the loop is complete, the final modified string is simply returned.</p>
<p>As stated previously, this Filter, and the Namespace Filter are built into the "asString" method. But if you want to
create a Filter of your own, you can simply pass it in as a parameter. So if you have a custom Filter called
"BadTagRemoverFilter", you could use it like this:</p>
<pre><code class="language-php">...

$page-&gt;asString(new BadTagRemoverFilter());
</code></pre>
<p>Your Filter would be applied, and all those pesky bad tags would be gone from your final output.</p>
<p>And that is Templado!</p>
<h3 id="conclusion">Conclusion</h3>
<p>We have gone over all the ways that Templado can be used to manipulate templates. As should be evident, Templado is
powerful, yet simple and concise. And most importantly Templado allows you to use plain XHTML documents as templates.
All of your stakeholders will be able to see and understand.</p>
<p>There is one final thing to point out. In the beginning, the method of using PHP View Models was illustrated. The Templado
engine relies on these View Models. However there is a separate repository in the Templado family that has two Mappers -
A JSON Mapper, and an XML Mapper. The usage for either one is mostly the same, and very simple:</p>
<pre><code class="language-php">$input = file_get_contents(__DIR__ . '/viewmodel/viewmodel.json');
$mapper = new JsonMapper();
$obj = $mapper-&gt;fromString($input);

$page-&gt;applyViewModel($obj);
</code></pre>
<p>In the above example a new JsonMapper is instantiated. Then the "fromString"  method is called, and the JSON string is
passed in. This creates a View Model Object that can then be passed into the "applyViewModel" method.</p>
<p>For XML it is similar, but with a few slight differences. First the Mapper is called DomDocumentMapper. So you would
instantiate that one. Then instead of a string, this Mapper expects either a PHP DOMDocument, or a DOMElement. So you
would need to create one of those from your XML, and then pass it to the appropriate method - either the
"fromDomDocument" method, or the "fromDomElement". Kind of makes since if you think about it, huh?!</p>
<p><strong>Note: The mappers are meant as mere helpers to have a generic mapping from json data structures into view models. They
are not a part of the engine repository, because they are not the recommended way of doing things. It is generally better
to write your own View Models.</strong></p>
<p>Anyway, that is it. For more in depth usage of the mappers, look to the documentation for the Mapper repository. Otherwise,
good luck templating with Templado, and please let us know what you think.</p>
<h2 id="examples">Examples</h2>
<p>Usage examples can be found in the <a href="https://github.com/templado/examples">example project</a></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../install/" class="btn btn-neutral float-left" title="Installation"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../concept/viewmodel/" class="btn btn-neutral float-right" title="View Models">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright &copy; 2023, Arne Blankerts and contributors</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/templado/documentation" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../install/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../concept/viewmodel/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../highlight/highlight.min.js"></script>
      <script src="../highlight/all.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
